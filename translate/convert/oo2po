#!/usr/bin/env python
#
# Copyright 2002-2004 Zuza Software Foundation
# 
# This file is part of translate.
#
# translate is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# translate is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with translate; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

"""Converts OpenOffice.org exported .oo files to Gettext .po files"""

from translate.storage import po
from translate.storage import oo
from translate.misc import quote
from translate.convert import convert
from translate import __version__
import os

# TODO: support using one GSI file as template, another as input (for when English is in one and translation in another)

class GSIConvertOptionParser(convert.ConvertOptionParser):
  def __init__(self, formats, usetemplates=False, usepots=False, description=None):
    convert.ConvertOptionParser.__init__(self, formats, usetemplates, usepots, description=description)

  def isrecursive(self, fileoption):
    """checks if fileoption is a recursive file"""
    if self.isgsi(fileoption): return True
    return super(GSIConvertOptionParser, self).isrecursive(fileoption)

  def isgsi(self, fileoption):
    """returns whether the file option is a multi-module gsi file"""
    return isinstance(fileoption, (str, unicode)) and fileoption.endswith(os.extsep + "gsi") and os.path.isfile(fileoption)

  def recurseinputfiles(self, options):
    """recurse through gsi file / directories and return files to be converted"""
    if self.usetemplates and options.template and self.isgsi(options.template):
      options.templategsi = oo.oomultifile(open(options.template, 'r'))
    if self.isgsi(options.input):
      options.inputgsi = oo.oomultifile(open(options.input, 'r'))
      return self.recursegsifiles(options)
    else:
      return super(GSIConvertOptionParser, self).recurseinputfiles(options)

  def recursegsifiles(self, options):
    """recurse through gsi files and convert files"""
    inputfiles = []
    for inputpath in options.inputgsi.listsubfiles():
      top, name = os.path.split(inputpath)
      if not self.isvalidinputname(options, name):
        continue
      inputfiles.append(inputpath)
    return inputfiles

  def openinputfile(self, options, fullinputpath):
    """opens the input file"""
    if self.isgsi(options.input):
      return options.inputgsi.openfile(fullinputpath)
    else:
      return super(GSIConvertOptionParser, self).openinputfile(options, fullinputpath)

  def getfullinputpath(self, options, inputpath):
    """gets the absolute path to an input file"""
    if self.isgsi(options.input):
      return inputpath
    else:
      return os.path.join(options.input, inputpath)

  def opentemplatefile(self, options, fulltemplatepath):
    """opens the template file (if required)"""
    if fulltemplatepath is not None:
      if self.isgsi(options.template):
        if fulltemplatepath in options.templategsi.listmodules():
          return options.templategsi.openfile(fulltemplatepath)
        else:
          self.warning("missing template file %s" % fulltemplatepath)
    return super(GSIConvertOptionParser, self).opentemplatefile(options, fulltemplatepath)

  def getfulltemplatepath(self, options, templatepath):
    """gets the absolute path to a template file"""
    if templatepath is not None and self.usetemplates and options.template:
      if self.isgsi(options.template):
        return templatepath
      else:
        return os.path.join(options.template, templatepath)
    else:
      return None

  def templateexists(self, options, templatepath):
    """returns whether the given template exists..."""
    if templatepath is not None:
      if self.isgsi(options.template):
        return templatepath in options.templategsi.listmodules()
    return super(GSIConvertOptionParser, self).templateexists(options, templatepath)

class oo2po:
  def __init__(self, languages=None, blankmsgstr=False):
    """construct an oo2po converter for the specified languages"""
    # languages is a pair of language ids
    self.languages = languages
    self.blankmsgstr = blankmsgstr

  def makepo(self, part1, part2, key, subkey):
    """makes a po element out of a subkey of two parts"""
    thepo = po.poelement()
    thepo.sourcecomments.append("#: " + key + "." + subkey + "\n")
    text1 = getattr(part1, subkey)
    text2 = getattr(part2, subkey)
    thepo.msgid = [quote.quotestr(line) for line in text1.split('\n')]
    thepo.msgstr = [quote.quotestr(line) for line in text2.split('\n')]
    return thepo

  def makekey(self, ookey):
    """converts an oo key tuple into a key identifier for the po file"""
    project, sourcefile, resourcetype, groupid, localid, platform = ookey
    sourcefile = sourcefile.replace('\\','/')
    if (groupid) == 0 or len(localid) == 0:
      ooid = groupid + localid
    else:
      ooid = groupid + "." + localid
    key = "%s/%s#%s" % (project, sourcefile, ooid)
    return oo.normalizefilename(key)

  def convertelement(self, theoo):
    """convert an oo element into a list of po elements"""
    if self.blankmsgstr:
      if self.languages is None:
        part1 = theoo.lines[0]
      else:
        part1 = theoo.languages[self.languages[0]]
      # use a blank part2
      part2 = oo.ooline()
    else:
      if self.languages is None:
        part1 = theoo.lines[0]
        part2 = theoo.lines[1]
      else:
        try:
          part1 = theoo.languages[self.languages[0]]
          part2 = theoo.languages[self.languages[1]]
        except KeyError, e:
          # TODO: handle this more gracefully...
          print theoo.lines[0].getkey(), "language not found: %s" % e
          return []
    key = self.makekey(part1.getkey())
    textpo = self.makepo(part1, part2, key, 'text')
    quickhelppo = self.makepo(part1, part2, key, 'quickhelptext')
    titlepo = self.makepo(part1, part2, key, 'title')
    polist = [textpo, quickhelppo, titlepo]
    return polist

  def convertfile(self, theoofile, filename="unknown file"):
    """converts an entire oo file to .po format"""
    thepofile = po.pofile()
    # create a header for the file
    headerpo = thepofile.makeheader(charset="UTF-8", encoding="8bit")
    headerpo.othercomments.append("# extracted from %s\n" % filename)
    thepofile.poelements.append(headerpo)
    # go through the oo and convert each element
    for theoo in theoofile.ooelements:
      polist = self.convertelement(theoo)
      for thepo in polist:
        thepofile.poelements.append(thepo)
    thepofile.removeblanks()
    thepofile.removeduplicates()
    return thepofile

def convertoo(inputfile, outputfile, templates, pot=False, languages=None):
  """reads in stdin using fromfileclass, converts using convertorclass, writes to stdout"""
  fromfile = oo.oofile()
  filelines = inputfile.readlines()
  fromfile.fromlines(filelines)
  if languages is not None:
    languages = [language.strip() for language in languages.split(",") if language.strip()]
  convertor = oo2po(blankmsgstr=pot, languages=languages)
  outputpo = convertor.convertfile(fromfile)
  if outputpo.isempty():
    return 0
  outputpolines = outputpo.tolines()
  outputfile.writelines(outputpolines)
  return 1

if __name__ == '__main__':
  # handle command line options
  from translate.convert import convert
  formats = {"oo":("po",convertoo)}
  parser = GSIConvertOptionParser(formats, usepots=True, description=__doc__)
  parser.add_option("-l", "--languages", dest="languages", default=None,
    help="set languages to extract from oo file (comma-separated)", metavar="LANGUAGES")
  parser.passthrough.append("pot")
  parser.passthrough.append("languages")
  parser.run()

