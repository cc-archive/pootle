#!/usr/bin/env python
# 
# Copyright 2002, 2003 Zuza Software Foundation
# 
# This file is part of translate.
#
# translate is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# translate is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with translate; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

"""takes a .po translation file and produces statistics to help work out what encoding it is in"""

import sys
import os
from translate.storage import po
from translate import __version__
import encodings
import codecs
import string

class detector:
  excludechoices={'letters':string.letters, 'digits':string.digits,
                  'whitespace':string.whitespace, 'punctuation':string.punctuation,
                  'std':string.letters+string.digits+string.whitespace+string.punctuation}

  def __init__(self, filenames, options):
    self.outputencoding = options.outputencoding
    self.limitencodings = options.limitencodings
    self.alloriginals, self.alltranslations = [], []
    for filename in filenames:
      if not os.path.exists(filename):
        print >>sys.stderr, "cannot process %s: does not exist" % filename
        continue
      elif os.path.isdir(filename):
        self.handledir(filename)
      else:
        self.handlefile(filename)
    if options.dictfile:
      self.dictstring = codecs.open(options.dictfile, 'r', options.dictencoding).read()
    else:
      self.dictstring = None
    self.options = options
    self.excludestring = ""
    if options.exclude:
      for excludecategory in options.exclude:
        if excludecategory in self.excludechoices:
          self.excludestring += self.excludechoices[excludecategory]

  def listencodings(self):
    if self.limitencodings is not None:
      return self.limitencodings.split(",")
    modules = encodings.aliases.aliases.values()
    moduledict = dict([(module, True) for module in modules])
    modules = moduledict.keys()
    modules.sort()
    return modules

  def processoriginal(self, original):
    self.alloriginals.append(original)

  def processtranslation(self, translation):
    self.alltranslations.append(translation)

  def processfile(self, infile):
    pof = po.pofile()
    pof.fromlines(infile.readlines())
    originals, translations = [], []
    for poe in pof.poelements:
      if poe.isheader() or poe.isblank():
        continue
      msgid = po.getunquotedstr(poe.msgid)
      if isinstance(poe.msgstr, dict):
        msgstr = po.getunquotedstr(poe.msgstr[0])
      else:
        msgstr = po.getunquotedstr(poe.msgstr)
      self.processoriginal(msgid)
      self.processtranslation(msgstr)

  def handlefile(self, filename):
    infile = open(filename)
    self.processfile(infile)
    infile.close()
    print filename

  def handlefiles(self, arg, dirname, filenames):
    for filename in filenames:
      pathname = os.path.join(dirname, filename)
      if not os.path.isdir(pathname):
        self.handlefile(pathname)

  def handledir(self, dirname):
    os.path.walk(dirname, self.handlefiles, None)

  def updatecountmap(self, charstring, excludestring="", countmap=None):
    """makes a countmap of the characters in the string, excluding those in excludestring
    starts with countmap if one is given"""
    if countmap is None: countmap = {}
    for char in charstring:
      if char in excludestring: continue
      if char in countmap: countmap[char] += 1
      else: countmap[char] = 1
    return countmap

  def getcountmapdelta(self, countmap1, countmap2):
    """returns a delta representing the difference between the two countmaps"""
    total1 = reduce(int.__add__, countmap1.values())
    total2 = reduce(int.__add__, countmap2.values())
    delta = 0
    for char in countmap1:
      adjustedcount = (countmap1[char]*total2)/total1
      if char in countmap2:
        delta += abs(adjustedcount - countmap2[char])
      else:
        delta += adjustedcount
    for char in countmap2:
      if char not in countmap1:
        delta += countmap2[char]
    return delta

  def countmaptostring(self, countmap):
    """returns a string with the characters in countmap sorted by count"""
    countpairs = [(count, char) for char,count in countmap.iteritems()]
    countpairs.sort()
    countpairs.reverse()
    return "".join([char for count,char in countpairs])

  def encodeattempt(self, charstring):
    """encode what can be encoding in encoding, add the rest on at the end in a repr"""
    try:
      return charstring.encode(self.outputencoding)
    except:
      encoded = ""
      failed = ""
      for char in charstring:
        try:
          encoded += char.encode(self.outputencoding)
        except:
          failed += char
      return encoded + " " + repr(failed)

  def makecountmap(self, encoding):
    """makes a countmap for all the translations using the encoding"""
    countmap = {}
    for translation in self.alltranslations:
      try:
        decoded = translation.decode(encoding)
      except UnicodeDecodeError:
        continue
      self.updatecountmap(decoded, self.excludestring, countmap)
    return countmap

  def testcharstats(self):
    dictcountmap = {}
    if self.dictstring:
      self.updatecountmap(self.dictstring, self.excludestring, dictcountmap)
    validencodings = {}
    encodingdeltas = {}
    for encoding in self.listencodings():
      validencodings[encoding] = self.makecountmap(encoding)
      if dictcountmap:
        encodingdeltas[encoding] = self.getcountmapdelta(dictcountmap, countmap)
    if self.dictstring:
      sortedstring = self.countmaptostring(dictcountmap)
      print "dict:", self.encodeattempt(sortedstring)
      deltas = [(delta, encoding) for encoding, delta in encodingdeltas.iteritems()]
      deltas.sort()
      validkeys = [encoding for delta, encoding in deltas]
    else:
      # sort alphabetically
      validkeys = validencodings.keys()
      validkeys.sort()
    keylen = max([len("%s (%d):" % (key, encodingdeltas[key])) for key in validencodings])
    for validencoding in validkeys:
      sortedstring = self.countmaptostring(validencodings[validencoding])
      validencoding = "%s (%d):" % (validencoding, encodingdeltas[validencoding])
      validencoding += " "*(keylen-len(validencoding))
      print validencoding, self.encodeattempt(sortedstring)

  def fuzzy(self, word, includestring):
    """return a version of word including all the characters in includestring, with sequences of other characters replaced by a space"""
    # the dots cleverly help us catch start and end spaces
    fuzzyword = '.'
    for char in word:
      if char in includestring:
        fuzzyword += char
      else:
        fuzzyword += ' '
    fuzzyword += '.'
    return ' '.join(fuzzyword.split())[1:-1]

  def testwordstats(self):
    ignoremap = {}
    for excludedchar in self.excludestring:
      ignoremap[ord(excludedchar)] = u' '
    dictmap = {}
    if self.dictstring:
      for dictword in self.dictstring.split():
        if not dictword.translate(ignoremap).isspace():
          if self.options.fuzzymatch:
            dictmap[self.fuzzy(dictword, self.excludestring)] = dictword
          else:
            dictmap[dictword.lower()] = 0
    print "%d words in dictionary" % len(dictmap)
    if self.options.verbose and False:
      if self.options.fuzzymatch:
        for fuzzy, word in dictmap.iteritems():
          print fuzzy, word
      else:
        for word in dictmap:
          print repr(word)
    encodingcounts = {}
    uniquewordsfound = {}
    for encoding in self.listencodings():
      try:
        wordsfound = 0
        for translation in self.alltranslations:
          try:
            decoded = translation.decode(encoding)
          except UnicodeDecodeError:
            raise
          except Exception, e:
            raise UnicodeDecodeError(encoding, translation, 0, 0, str(e))
          decodedwords = translation.lower().split()
          for word in decodedwords:
            if self.options.fuzzymatch:
              fuzzyword = self.fuzzy(word, self.excludestring)
              if fuzzyword in dictmap:
                wordsfound += 1
                if self.options.verbose:
                  if (not self.options.unique) or (word not in uniquewordsfound):
                    print repr(word), repr(fuzzyword), repr(dictmap[fuzzyword])
                uniquewordsfound[word] = fuzzyword
            else:
              if word in dictmap:
                uniquewordsfound[word] = 1
                wordsfound += 1
        if options.unique:
          encodingcounts[encoding] = len(uniquewordsfound)
        else:
          encodingcounts[encoding] = wordsfound
      except UnicodeDecodeError:
        continue
    counts = [(count, encoding) for encoding, count in encodingcounts.iteritems()]
    counts.sort()
    validkeys = [encoding for count, encoding in counts]
    for validencoding in validkeys:
      count = encodingcounts[validencoding]
      if count:
        print "%s: %d" % (validencoding, count)

if __name__ == '__main__':
  try:
    import optparse
  except ImportError:
    from translate.misc import optparse
  optparser = optparse.OptionParser(version="%prog "+__version__.ver)
  optparser.add_option("", "--exclude", dest="exclude", type="choice",
    action="append", choices=detector.excludechoices.keys(),
    help="exclude certain common characters (%s)" % ", ".join(detector.excludechoices))
  optparser.add_option("", "--dict", dest="dictfile",
    action="store", default=None,
    help="use a dictionary/wordlist to choose the best encoding(s)")
  optparser.add_option("", "--dictencoding", dest="dictencoding",
    action="store", default="utf8",
    help="the encoding of the dictionary/wordlist")
  optparser.add_option("", "--outputencoding", dest="outputencoding",
    action="store", default="iso-8859-1",
    help="the encoding of the output")
  optparser.add_option("", "--matchwords", dest="matchwords",
    action="store_true", default=False,
    help="match words to the dictionary")
  optparser.add_option("", "--matchchars", dest="matchchars",
    action="store_true", default=False,
    help="match chars to the dictionary")
  optparser.add_option("", "--fuzzymatch", dest="fuzzymatch",
    action="store_true", default=False,
    help="match words to the dictionary using a fuzzy algorithm...")
  optparser.add_option("", "--limitencodings", dest="limitencodings",
    action="store", default=None,
    help="only use the encodings specified")
  optparser.add_option("-u", "--unique", dest="unique",
    action="store_true", default=False,
    help="only use unique words found, not total")
  optparser.add_option("-v", "--verbose", dest="verbose",
    action="store_true", default=False,
    help="verbose (print out lots of strings)")
  (options, args) = optparser.parse_args()
  d = detector(args, options)
  if options.matchwords:
    d.testwordstats()
  if options.matchchars:
    d.testcharstats()

