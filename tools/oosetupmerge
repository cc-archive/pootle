#!/usr/bin/env python

"""tool for building multilingual openoffice.org setup files"""

try:
  from translate.misc import sparse
except ImportError:
  import sparse
try:
  from translate import __version__
except ImportError:
  class __version__:
    ver = "standalone"
import sys
import operator
import os
import copy
import datetime

class SetupParser(sparse.SimpleParser):
  def __init__(self):
    sparse.SimpleParser.__init__(self)
    self.defaulttokenlist.extend(';\n')
    self.whitespacechars = " \t\r"
    self.quotechars = ('"', '{')
    self.endquotechars = {'"':'"', '{':'}'}
    self.stringescaping = 0
    self.sectiontypes = ('ConfigurationItem', 'Custom', 'DataCarrier', 'Directory',
      'File', 'Folder', 'FolderItem', 'Function', 'HelpText', 'Installation', 'Module', 'Procedure',
      'Profile', 'ProfileItem', 'RegistryItem', 'Shortcut', 'StarRegistry', 'StarRegistryItem')
    self.definitions = {}
    self.bytype = {}
    self.referrals = []
    # insert after the given tokennums
    self.insertions = {}
    for sectiontype in self.sectiontypes:
      self.bytype[sectiontype] = {}

  def parse(self, contents):
    self.tokenize(contents)
    self.originaltokens = self.tokens[:]
    tokennum = 0
    while tokennum < len(self.tokens):
      tokennum = self.parsesection(tokennum)

  def parsesection(self, tokennum):
    sectiontype = self.tokens[tokennum]
    if sectiontype not in self.sectiontypes:
      print >>sys.stderr, "unknown sectiontype....", sectiontype
      if sectiontype not in self.bytype:
        self.bytype[sectiontype] = {}
    sectionname = self.tokens[tokennum + 1]
    section = {}
    if sectionname in self.definitions:
      print >>sys.stderr, "duplicate", sectionname
    self.definitions[sectionname] = section
    self.bytype[sectiontype][sectionname] = section
    section['type'] = sectiontype
    section['tokennums'] = {'start':tokennum}
    tokennum += 2
    while self.tokens[tokennum] == '\n':
      tokennum += 1
    while self.tokens[tokennum].lower() != 'end':
      varname = self.tokens[tokennum]
      if self.tokens[tokennum+1] != '=':
        print >>sys.stderr, "expected =...", sectiontype, sectionname, varname
      startvardef = tokennum+2
      nestlevel = 0
      while self.tokens[tokennum] != '\n' or nestlevel > 0:
        varpart = self.tokens[tokennum]
        if varpart.lower().startswith('gid_'):
          self.referrals.append((varpart, tokennum))
        if varpart == '(':
          nestlevel += 1
        elif varpart == ')':
          nestlevel -= 1
        tokennum += 1
      value = "".join(self.tokens[startvardef:tokennum])
      if value.endswith(";"): value = value[:-1]
      section[varname] = value
      section['tokennums'][varname] = startvardef - section['tokennums']['start']
      tokennum = tokennum + 1
    section['tokennums']['end'] = tokennum - section['tokennums']['start']
    tokennum += 1
    while tokennum < len(self.tokens) and self.tokens[tokennum] == '\n':
      tokennum += 1
    return tokennum

  def rename(self, sectionname, newname):
    section = self.definitions[sectionname]
    tokennum = section['tokennums']['start']
    self.tokens[tokennum+1] = newname
    for varpart, tokennum in self.referrals:
      if varpart.lower() == sectionname.lower():
        self.tokens[tokennum] = newname

  def insertforeignsection(self, aftersection, sectionname, section, index, tokenrange):
    tokennum = self.getsectionendtokennum(aftersection)
    while self.tokens[tokennum+1] == '\n':
      tokennum += 1
    self.definitions[sectionname] = copy.deepcopy(section)
    self.definitions[sectionname]['tokennums']['start'] = tokennum
    if tokennum in self.insertions:
      self.insertions[tokennum].append((index, tokenrange))
    else:
      self.insertions[tokennum] = [(index, tokenrange)]

  def getsource(self, start=None, end=None):
    sourceparts = []
    if start is None:
      start = 0
    if end is None:
      end = len(self.tokens)
    tokenpos = 0
    for tokennum in range(start+1):
      tokenpos = self.source.find(self.originaltokens[tokennum], tokenpos)
    for tokennum in range(start, end):
      originaltoken = self.originaltokens[tokennum]
      nexttokenpos = self.source.find(originaltoken, tokenpos)
      sourceparts.append(self.source[tokenpos:nexttokenpos])
      sourceparts.append(self.tokens[tokennum])
      tokenpos = nexttokenpos + len(originaltoken)
      if tokennum in self.insertions:
        for index, tokenrange in self.insertions[tokennum]:
          foreignstart, foreignend = tokenrange
          foreignsource = index.getsource(foreignstart, foreignend)
          sourceparts.append(foreignsource)
    if end == len(self.tokens):
      sourceparts.append(self.source[tokenpos:end])
    return "".join(sourceparts)

  def getfieldvalue(self, sectionname, fieldname, default=None):
    section = self.definitions[sectionname]
    return section.get(fieldname, default)

  def getfieldtokennum(self, sectionname, fieldname):
    section = self.definitions[sectionname]
    return section['tokennums'][fieldname] + section['tokennums']['start']

  def getsectionendtokennum(self, sectionname):
    section = self.definitions[sectionname]
    return section['tokennums']['end'] + section['tokennums']['start']

  def setfieldvalue(self, sectionname, fieldname, fieldvalue):
    fieldtokennum = self.getfieldtokennum(sectionname, fieldname)
    self.tokens[fieldtokennum] = fieldvalue

  def getsectiontokenrange(self, sectionname):
    section = self.definitions[sectionname]
    start, end = section['tokennums']['start'], section['tokennums']['end']+1
    while self.tokens[start+end] == '\n' and start+end < len(self.tokens)-1:
      end += 1
    return (start, start+end)

  def getmoduleentrytokennum(self, modulename, fileentry):
    start, end = self.getsectiontokenrange(modulename)
    for tokennum in range(start, end):
      if self.originaltokens[tokennum] == fileentry:
        return tokennum
    return None

class SetupIndex(SetupParser):
  def __init__(self, filename=None):
    SetupParser.__init__(self)
    self.manualfiles = []
    if filename is not None:
      self.readfile(filename)

  def readfile(self, filename):
    self.filename = filename
    # f = codecs.open(self.filename, 'r', encoding='utf8')
    f = open(self.filename, 'r')
    contents = f.read()
    f.close()
    self.parse(contents)

  def parse(self, contents):
    SetupParser.parse(self, contents)
    self.languagename = sparse.stringeval(self.getfieldvalue('gid_Dir_Config_Language', 'HostName'))
    self.isocode = sparse.stringeval(self.getfieldvalue('gid_Dir_Share_Registry_Res_Lang', 'HostName'))
    self.dialingcode = sparse.stringeval(self.getfieldvalue('gid_Installation', 'DefaultLanguage'))

  def keymunge(self, keyname):
    """munges a keyname and removes invalid entries"""
    return keyname.replace("-", "_")

  def islocalizefile(self, filename):
    """returns whether a file is part of localization"""
    # handle resource files
    if filename.endswith("%s.res" % self.dialingcode):
      return True
    # handle README and LICENSE files
    if filename in [(template % self.dialingcode) for template in \
                    ("README%s", "LICENSE%s", "README%s.html", "LICENSE%s.html")]:
      return True
    # everything else is normal...
    return False

  def merge(self, otherindexes):
    """merges this with another index... hmmm ...."""
    indexes = [self] + otherindexes
    languages = [index.getfieldvalue('gid_Installation', 'Languages') for index in indexes]
    languages = [sparse.stringeval(languagevalues).split(",") for languagevalues in languages]
    languages = reduce(operator.add, languages)
    languages.sort()
    languages = ",".join(languages)
    # TODO: reset the Languages list when supported by setup.ins
    # support for Languages is needed in setup2/source/ui/pages/plang.*
    # self.setfieldvalue('gid_Installation', 'Languages', '"%s"' % languages)
    # can't do anything about HelpText yet...
    directoriestorename = {}
    for index in indexes:
      index.directorychildren = {}
      index.directoryfiles = {}
      for directory in index.bytype["Directory"]:
        hostname = index.getfieldvalue(directory, 'HostName')
        hostname = sparse.stringeval(hostname)
        if hostname == self.languagename or hostname == self.isocode:
          directoriestorename[directory] = 1
        parentid = index.getfieldvalue(directory, 'ParentID')
        if parentid not in index.directorychildren:
          index.directorychildren[parentid] = [directory]
        else:
          index.directorychildren[parentid].append(directory)
      # make an index of which files go in which directory
      for fileentry in index.bytype["File"]:
        directory = index.getfieldvalue(fileentry, 'Dir')
        if directory not in index.directoryfiles:
          index.directoryfiles[directory] = [fileentry]
        else:
          index.directoryfiles[directory].append(fileentry)
      # make an index of which modules files belong to...
      index.filemodules = {}
      for module in index.bytype["Module"]:
        filelist = index.getfieldvalue(module, 'Files', None)
        if filelist is None:
          # not all modules have a file list
          continue
        filelist = [fileentry.strip() for fileentry in filelist[1:-1].split(",")]
        for fileentry in filelist:
          if fileentry not in index.filemodules:
            index.filemodules[fileentry] = [module]
          else:
            index.filemodules[fileentry].append(module)
    for index in indexes:
      for directory in directoriestorename:
        suffix = "_" + index.isocode
        suffix = self.keymunge("_" + index.isocode)
        if directory.find('_Language') != -1:
          newname = directory.replace("_Language", suffix)
        elif directory.find('_Lang') != -1:
          newname = directory.replace("_Lang", suffix)
        elif directory.find('_Isolanguage') != -1:
          newname = directory.replace("_Isolanguage", suffix)
        else: newname = directory + suffix
        index.renamedirectory(directory, newname, suffix)
        if index != self:
          directorysection = index.definitions[directory]
          tokenrange = index.getsectiontokenrange(directory)
          self.insertforeignsection(directory, newname, directorysection, index, tokenrange)
          if directory in index.directoryfiles:
            for fileentry in index.directoryfiles[directory]:
              self.addforeignfile(index, fileentry, suffix)
      for fileentry in index.bytype["File"]:
        filename = sparse.stringeval(index.getfieldvalue(fileentry, 'Name'))
        if index.islocalizefile(filename):
          suffix = self.keymunge("_" + index.isocode)
          index.rename(fileentry, fileentry + suffix)
          packedname = sparse.stringeval(index.getfieldvalue(fileentry, "PackedName"))
          newpackedname = packedname + suffix
          index.setfieldvalue(fileentry, "PackedName", '"%s"' % newpackedname)
          if index != self:
            self.addforeignfile(index, fileentry, suffix)
      for configitem in index.bytype["ConfigurationItem"]:
        key = sparse.stringeval(index.getfieldvalue(configitem, 'Key'))
        if configitem == "gid_Configurationitem_Setup_Office_Locales":
          # wierdness. the setup program will put in a comma-separated attribute if its all alpha
          # but if there's a - it won't, so we need to check for this...
          # TODO: work out a better fix
          isocodes = ",".join([eachindex.isocode for eachindex in indexes if eachindex.isocode.isalpha()])
          index.setfieldvalue(configitem, "Value", '"%s"' % isocodes)
        if key == index.isocode:
          suffix = self.keymunge("_" + index.isocode)
          index.rename(configitem, configitem + suffix)
          if index != self:
            self.addforeignconfigitem(index, configitem, suffix)

  def addmanualfile(self, fileentry, filename, packedname, baseentry):
    """Inserts an external file into the build system"""
    fileinfo = os.stat_result(os.stat(filename))
    filedate = datetime.datetime.fromtimestamp(fileinfo.st_mtime)
    direntry = self.getfieldvalue(baseentry, "Dir")
    filesectionlines = ["File %s" % fileentry]
    def addparam(paramname, paramstr):
      filesectionlines.append("        %s%s = %s;" % (paramname, " "*(16-len(paramname)), paramstr))
    addparam("Name", '"%s"' % os.path.basename(filename))
    addparam("PackedName", '"%s"' % packedname)
    addparam("Size", "%d" % fileinfo.st_size)
    addparam("Dir", "%s" % direntry)
    addparam("Carrier", "gid_DataCarrier")
    addparam("UnixRights", ("%o" % fileinfo.st_mode)[-3:])
    addparam("Date", filedate.strftime('"%d%m%Y"'))
    addparam("Time", filedate.strftime('"%H%M"'))
    addparam("Styles", "(PACKED)")
    filesectionlines.append("End")
    filesectionlines.extend(["", "", ""])
    filesectionstr = "\r\n".join(filesectionlines)
    dummysetup = SetupParser()
    dummysetup.parse(filesectionstr)
    fileentrysection = dummysetup.definitions[fileentry]
    tokenrange = dummysetup.getsectiontokenrange(fileentry)
    self.insertforeignsection(baseentry, fileentry, fileentrysection, dummysetup, tokenrange)
    if baseentry in self.filemodules:
      for modulename in self.filemodules[baseentry]:
        self.addfiletomodule(modulename, fileentry, baseentry)
    self.manualfiles.append((filename, packedname))

  def addforeignconfigitem(self, index, configitem, suffix):
    """adds the foreign config item and updates the modules list..."""
    tokenrange = index.getsectiontokenrange(configitem)
    configitemsection = index.definitions[configitem]
    # the config item will already have been renamed by the index.renamedirectory
    self.insertforeignsection(configitem, configitem + suffix, configitemsection, index, tokenrange)

  def addforeignfile(self, index, fileentry, suffix):
    """adds the foreign file entry and updates the modules list..."""
    tokenrange = index.getsectiontokenrange(fileentry)
    fileentrysection = index.definitions[fileentry]
    # the file will already have been renamed by the index.renamedirectory
    self.insertforeignsection(fileentry, fileentry + suffix, fileentrysection, index, tokenrange)
    if fileentry in self.filemodules:
      for modulename in self.filemodules[fileentry]:
        self.addfiletomodule(modulename, fileentry + suffix, fileentry)

  def addfiletomodule(self, modulename, fileentry, afterfileentry):
    """adds the given fileentry to module modulename using the definition from the index"""
    tokennum = self.getmoduleentrytokennum(modulename, afterfileentry)
    dummysetuplines = ["Module %s" % modulename, "  Files = (dummy, %s);" % fileentry, "End", ""]
    dummyparser = SetupParser()
    dummyparser.parse("\r\n".join(dummysetuplines))
    dummytokennum = dummyparser.getmoduleentrytokennum(modulename, fileentry)
    insertion = (dummyparser, (dummytokennum - 1, dummytokennum + 1))
    if tokennum not in self.insertions:
      self.insertions[tokennum] = [insertion]
    else:
      self.insertions[tokennum].append(insertion)

  def renamedirectory(self, directory, newname, suffix):
    self.rename(directory, newname)
    if directory in self.directorychildren:
      for child in self.directorychildren[directory]:
        self.renamedirectory(child, child + suffix, suffix)
    if directory in self.directoryfiles:
      for fileentry in self.directoryfiles[directory]:
        self.rename(fileentry, fileentry + suffix)
        packedname = sparse.stringeval(self.getfieldvalue(fileentry, "PackedName", '""'))
        if packedname:
          self.setfieldvalue(fileentry, "PackedName", '"%s"' % (packedname+suffix))

  def makepackedname(self, prefix, offset=1):
    """finds a new packedname starting with prefix in the sequence"""
    packednames = [self.getfieldvalue(fileentry, "PackedName", '""') for fileentry in self.bytype['File']]
    packednames = map(sparse.stringeval, packednames)
    packednames = [packedname.replace(prefix,"",1) for packedname in packednames if packedname.startswith(prefix)]
    packednums = [filter(str.isdigit, packedname) for packedname in packednames]
    formatstring = '%s%0' + str(max(map(len, packednums))) + 'd'
    packednums = map(int, packednums)
    return formatstring % (prefix, max(packednums)+offset)

  def copyfiles(self, srcdirectory, destdirectory, onlychanged=0):
    """copy all the [changed] files listed in this setup file from srcdirectory to destdirectory"""
    for fileentry in self.bytype['File']:
      fileentrysection = self.definitions[fileentry]
      if 'PackedName' not in fileentrysection: continue
      packedtokennum = self.getfieldtokennum(fileentry, "PackedName")
      originalpackedname = sparse.stringeval(self.originaltokens[packedtokennum])
      packedname = sparse.stringeval(self.tokens[packedtokennum])
      if not onlychanged or packedname != originalpackedname:
        srcfile = os.path.join(srcdirectory, originalpackedname)
        destfile = os.path.join(destdirectory, packedname)
        if packedname != originalpackedname:
          print '%s -> %s' % (srcfile, destfile)
        os.system('cp -p %s %s' % (srcfile, destfile))
    for filename, packedname in self.manualfiles:
      packedpath = os.path.join(destdirectory, packedname)
      os.system('zip -j %s.zip %s' % (packedpath, filename))
      os.system('mv %s.zip %s' % (packedpath, packedpath))

if __name__ == '__main__':
  try:
    import psyco
    psyco.full()
  except:
    pass
  import optparse
  setupfiles = {}
  optparser = optparse.OptionParser(version="%prog "+__version__.ver, description=__doc__)
  optparser.set_usage("%prog maindir [--switchlangexe ooswitchlang.exe] [otherdirs] outputdir")
  optparser.add_option("", "--switchlangexe", dest="switchlangexe", default=None,
                  help="add SWITCHLANGEXE to program", metavar="SWITCHLANGEXE")
  options, args = optparser.parse_args()
  if len(args) < 2:
    optparser.error("need at least one inputdir and an outputdir")
  maindir = args[0]
  otherdirs = args[1:-1]
  outputdir = args[-1]
  if os.path.isfile(os.path.join(maindir, 'setup.ins')):
    setupname = 'setup.ins'
  elif os.path.isfile(os.path.join(maindir, 'setup.inf')):
    setupname = 'setup.inf'
  else:
    print >>sys.stderr, "could not find setup.ins or setup.inf in main input directory %s" % maindir
    sys.exit()
  mainsetupfile = SetupIndex(os.path.join(maindir, setupname))
  othersetupfiles = []
  for otherdir in otherdirs:
    othersetupfiles.append(SetupIndex(os.path.join(otherdir, setupname)))
  mainsetupfile.merge(othersetupfiles)
  if options.switchlangexe is not None:
    packedname = mainsetupfile.makepackedname("f_")
    mainsetupfile.addmanualfile("gid_File_Bin_switchlang", options.switchlangexe, packedname, "gid_File_Bin_Setofficelang")
  if not os.path.isdir(outputdir):
    os.mkdir(outputdir)
  open(os.path.join(outputdir, setupname), 'w').write(mainsetupfile.getsource())
  mainsetupfile.copyfiles(maindir, outputdir)
  for dirnum in range(len(otherdirs)):
    otherdir = otherdirs[dirnum]
    othersetupfile = othersetupfiles[dirnum]
    othersetupfile.copyfiles(otherdir, outputdir, 1)
  # copy other unmodified files
  for filename in os.listdir(maindir):
    checkname = filename.lower()
    if checkname.startswith('f') or checkname == setupname:
      continue
    srcfile = os.path.join(maindir, filename)
    destfile = os.path.join(outputdir, filename)
    print '%s -> %s' % (srcfile, destfile)
    os.system('cp -p %s %s' % (srcfile, destfile))
    # also copy the following files to language-specific names
    if checkname.startswith("readme") or checkname.startswith("license") or checkname.endswith("html"):
      extpos = filename.rfind(os.extsep)
      if extpos == -1:
        destname = filename + "-" + mainsetupfile.isocode
      else:
        destname = filename[:extpos] + "-" + mainsetupfile.isocode + filename[extpos:]
      destfile = os.path.join(outputdir, destname)
      print '%s -> %s' % (srcfile, destfile)
      os.system('cp -p %s %s' % (srcfile, destfile))
  for dirnum in range(len(otherdirs)):
    otherdir = otherdirs[dirnum]
    setupfile = othersetupfiles[dirnum]
    for filename in os.listdir(otherdir):
      checkname = filename.lower()
      if checkname.startswith('f') or checkname == setupname:
        continue
      # we want readmes in every language...
      if checkname.startswith("readme") or checkname.startswith("license") or checkname.endswith("html"):
        srcfile = os.path.join(otherdir, filename)
        extpos = filename.rfind(os.extsep)
        if extpos == -1:
          destname = filename + "-" + setupfile.isocode
        else:
          destname = filename[:extpos] + "-" + setupfile.isocode + filename[extpos:]
        destfile = os.path.join(outputdir, destname)
        print '%s -> %s' % (srcfile, destfile)
        os.system('cp -p %s %s' % (srcfile, destfile))



