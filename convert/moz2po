#!/usr/bin/env python
# 
# Copyright 2002, 2003 Zuza Software Foundation
# 
# This file is part of translate.
#
# translate is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# translate is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with translate; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

"""script that converts a set of .dtd and .properties files to a set of .po files"""

import os.path
import sys
try:
  import optparse
except ImportError:
  from translate.misc import optparse
from translate.convert import dtd2po
from translate.convert import prop2po
from translate.storage import dtd
from translate.storage import properties
from translate.storage import po
from translate.storage import xpi
from translate.misc import quote
from translate import __version__
from translate.convert import convert

class MozConvertOptionParser(convert.ConvertOptionParserExt):
  def __init__(self, inputformats, outputformats, usetemplates=False, usepots=False, templateslikeinput=None):
    convert.ConvertOptionParserExt.__init__(self, convert.defaultrecursion, inputformats, outputformats,
      usetemplates, usepots, templateslikeinput)

  def setrecursion(self, recursion):
    super(MozConvertOptionParser, self).setrecursion(recursion)
    self.argumentdesc = "xpi file/dir"

  def runconversion(self, options, convertmethod):
    """runs the conversion method using the given commandline options..."""
    if options.input is None:
      self.error(optparse.OptionValueError("cannot use stdin for xpi/recursive run. please specify inputfile"))
    elif os.path.isfile(options.input):
      options.inputxpi = xpi.XpiFile(options.input)
    elif not os.path.isdir(options.input):
      self.error(optparse.OptionValueError("inputfile must be file for xpi run or directory for recursive run."))
    if options.output is None:
      self.error(optparse.OptionValueError("must specify output directory for xpi/recursive run."))
    if not os.path.isdir(options.output):
      self.error(optparse.OptionValueError("output must be existing directory for xpi/recursive run."))
    if options.template and os.path.isfile(options.template):
      options.templatexpi = xpi.XpiFile(options.template)
    self.recurseconversion(options)

  def inputisxpi(self, options):
    """returns whether the input is via an xpi file"""
    return os.path.isfile(options.input)

  def templateisxpi(self, options):
    """returns whether the input is via an xpi file"""
    return os.path.isfile(options.template)

  def recursefiles(self, options):
    """recurse through xpi file / directories and return files to be converted"""
    if self.inputisxpi(options):
      return self.recursexpifiles(options)
    else:
      return super(MozConvertOptionParser, self).recursefiles(options)

  def recursexpifiles(self, options):
    """recurse through xpi files and convert files"""
    for inputpath in options.inputxpi.iterextractnames():
      top, name = os.path.split(inputpath)
      if not self.isvalidinputname(options, name):
        continue
      yield inputpath

  def openinputfile(self, options, fullinputpath):
    """opens the input file"""
    if self.inputisxpi(options):
      jarfilename, filename = options.inputxpi.ostojarpath(fullinputpath)
      return options.inputxpi.openinputstream(jarfilename, filename)
    else:
      return super(MozConvertOptionParser, self).openinputfile(options, fullinputpath)

  def getfullinputpath(self, options, inputpath):
    """gets the absolute path to an input file"""
    if self.inputisxpi(options):
      return inputpath
    else:
      return os.path.join(options.input, inputpath)

  def opentemplatefile(self, options, fulltemplatepath):
    """opens the template file (if required)"""
    if fulltemplatepath is not None:
      if self.templateisxpi(options):
        # TODO: deal with different names in input/template xpis
        jarfilename, filename = options.templatexpi.ostojarpath(fulltemplatepath)
        if options.templatexpi.jarfileexists(jarfilename, filename):
          return options.templatexpi.openinputstream(jarfilename, filename)
        else:
          print >>sys.stderr, "warning: missing template file %s" % fulltemplatepath
    return super(MozConvertOptionParser, self).opentemplatefile(options, fulltemplatepath)

  def getfulltemplatepath(self, options, templatepath):
    """gets the absolute path to a template file"""
    if templatepath is not None and self.usetemplates and options.template:
      if self.templateisxpi(options):
        return templatepath
      else:
        return os.path.join(options.template, templatepath)
    else:
      return None

if __name__ == '__main__':
  # TODO: add ability to import translations from another directory
  inputformats = {"dtd": dtd2po.convertdtd, "properties": prop2po.convertprop}
  outputformat = "po"
  parser = MozConvertOptionParser(inputformats, outputformat, usetemplates=True, usepots=True)
  (options, args) = parser.parse_args()
  try:
    parser.runconversion(options, None)
  except convert.optparse.OptParseError, message:
    parser.error(message)

