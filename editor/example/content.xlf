<?xml version="1.0" encoding="utf-8"?><!DOCTYPE xliff  PUBLIC '-//XLIFF//DTD XLIFF//EN'  'http://www.oasis-open.org/committees/xliff/documents/xliff.dtd'><xliff version="1.1">
  <file datatype="xml" date="2005-07-03" original="..\xliff_samples\samples\diveintopython-xml-5.4\diveintopython-5.4\xml\fileinfo.xml" source-language="en-US" target-language="KM-KH" xml:space="default">
    <header>
      <skl>
        <external-file href="skeleton.skl"/>
      </skl>
      <tool tool-id="http://transolution.python-hosting.com" tool-name="Transolution Generic sgml2xliff">
        <prop-group name="sourceinfo">
          <prop type="source-encoding">utf-8</prop>
        </prop-group>
      </tool>
    </header>
    <body>
      <trans-unit approved="yes" id="0" reformat="yes" translate="yes" xml:space="default">
        <source>Objects and Object-Orientation</source>
<<<<<<< .mine
        <target state="translated">Objects and Object-Orientations</target>
=======
        <target state="translated">Objects and Object-Orientationasdfafdas</target>
>>>>>>> .r3984
        <prop-group>
          <prop prop-type="entryid">1150875516735</prop>
        </prop-group>
      <note>aaaaaaaaaa,  ចម្រៀងខ្មែរ5</note><note>aaaaaaaaaa,  ចម្រៀងខ្មែរ5
Objects and Object-Orientation</note></trans-unit>
      
      <trans-unit approved="yes" id="1" reformat="yes" translate="yes" xml:space="default">
        <source>Chapter 5</source>
        <target state="translated">ចម្រៀងខ្មែរ5lkmkppo</target>
        <prop-group>
          <prop prop-type="entryid">1150875516738</prop>
        </prop-group>
      
      <note>ចម្រៀងខ្មែរ5[po[p[p</note></trans-unit>
      <trans-unit approved="yes" id="2" reformat="yes" translate="yes" xml:space="default">
        <source>This chapter, and pretty much every chapter after this, deals with object-oriented <ph id="1">&amp;python;</ph> programming.</source>
        <target state="translated">This chapter, and pretty much every chapter after this, deals with object-oriented &amp;python; programming.</target>
        <prop-group>
          <prop prop-type="entryid">1150875516739</prop>
        </prop-group>
      <note>finding note
cccccccfinding note
ccccccc
finding note
ccccccc
Object</note></trans-unit>
      <trans-unit approved="yes" id="3" reformat="yes" translate="yes" xml:space="default">
        <source>Diving In</source>
        <target/>
        <prop-group>
          <prop prop-type="entryid">1150875516740</prop>
        </prop-group>
      <note>ddddd</note></trans-unit>
      <trans-unit approved="no" id="4" reformat="yes" translate="yes" xml:space="default">
        <source>Here is a complete, working <ph id="1">&amp;python;</ph> program.</source>
        <target state="translated">Here is a complete, working &amp;python; program.</target>
        <prop-group>
          <prop prop-type="entryid">1150875516741</prop>
        </prop-group>
        
        
        
      <note>Tu4</note></trans-unit>
      <trans-unit approved="no" id="5" reformat="yes" translate="yes" xml:space="default">
        <source>Read the <bpt id="1">&lt;link linkend=&quot;odbchelper.docstring&quot;&gt;</bpt>
          <ph id="2">&amp;docstring;</ph>s<ept id="1">&lt;/link&gt;</ept> of the module, the classes, and the functions to get an overview of what this program does and how it works.</source>
        <target/>
        <prop-group>
          <prop prop-type="entryid">1150875516742</prop>
        </prop-group>
      <note>អត់​ទាន់​ចេះ​បក​ទេ</note></trans-unit>
      <trans-unit approved="no" id="6" reformat="yes" translate="yes" xml:space="default">
        <source>As usual, don't worry about the stuff you don't understand; that's what the rest of the chapter is for.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516743</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="7" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;fileinfo_filename;</ph>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516744</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="8" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;para_download;</ph>
        </source>
        <target state="translated">TU</target>
        <prop-group>
          <prop prop-type="entryid">1150875516745</prop>
        </prop-group>
      <note>TU8</note></trans-unit>
      <trans-unit approved="yes" id="9" reformat="yes" translate="yes" xml:space="default">
        <source>This program's output depends on the files on your hard drive.</source>
        <target/>
        <prop-group>
          <prop prop-type="entryid">1150875516749</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="10" reformat="yes" translate="yes" xml:space="default">
        <source>To get meaningful output, you'll need to change the directory path to point to a directory of MP3 files on your own machine.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516750</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="yes" id="11" reformat="yes" translate="yes" xml:space="default">
        <source>This is the output I got on my machine.</source>
        <target state="translated">This is the output I got on my machine.</target>
        <prop-group>
          <prop prop-type="entryid">1150875516751</prop>
        </prop-group>
        <note annotates="general" from="" priority="1"/>
        <note annotates="general" from="" priority="1"/>
      </trans-unit>
      <trans-unit approved="no" id="12" reformat="yes" translate="yes" xml:space="default">
        <source>Your output will be different, unless, by some startling coincidence, you share my exact taste in music.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516752</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="13" reformat="yes" translate="yes" xml:space="default">
        <source>Importing Modules Using <ph id="1">&amp;frommoduleimport;</ph>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516753</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="14" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph> has two ways of importing modules.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516754</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="15" reformat="yes" translate="yes" xml:space="default">
        <source>Both are useful, and you should know when to use each.</source>
        <target/>
        <prop-group>
          <prop prop-type="entryid">1150875516755</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="16" reformat="yes" translate="yes" xml:space="default">
        <source>One way, <ph id="1">&amp;importmodule;</ph>, you've already seen in <ph id="2">&lt;xref linkend=&quot;odbchelper.objects&quot;/&gt;</ph>. The other way accomplishes the same thing, but it has subtle and important differences.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516756</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="yes" id="17" reformat="yes" translate="yes" xml:space="default">
        <source>Here is the basic <ph id="1">&amp;frommoduleimport;</ph> syntax:</source>
        <target/>
        <prop-group>
          <prop prop-type="entryid">1150875516757</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="18" reformat="yes" translate="yes" xml:space="default">
        <source>This is similar to the <bpt id="1">&lt;link linkend=&quot;odbchelper.import&quot;&gt;</bpt>
          <ph id="2">&amp;importmodule;</ph>
          <ept id="1">&lt;/link&gt;</ept> syntax that you know and love, but with an important difference:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516759</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="19" reformat="yes" translate="yes" xml:space="default">
        <source>the attributes and methods of the imported module <ph id="1">&amp;types;</ph> are imported directly into the local namespace, so they are available directly, without qualification by module name.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516760</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="20" reformat="yes" translate="yes" xml:space="default">
        <source>You can import individual items or use <ph id="1">&amp;frommoduleimportstar;</ph> to import everything.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516761</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="21" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="open">&lt;note id=&quot;compare.fromimport.perl&quot; role=&quot;compare&quot; vendor=&quot;perl&quot;&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516762</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="22" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph>
          <ph id="2">&amp;vs;</ph>
          <ph id="3">&amp;perl;</ph>: <ph id="4">&amp;frommoduleimport;</ph>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516767</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="23" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;frommoduleimportstar;</ph> in <ph id="2">&amp;python;</ph> is like <bpt id="3">&lt;literal&gt;</bpt>use <bpt id="4">&lt;replaceable&gt;</bpt>module<ept id="4">&lt;/replaceable&gt;</ept>
          <ept id="3">&lt;/literal&gt;</ept> in <ph id="5">&amp;perl;</ph>; <ph id="6">&amp;importmodule;</ph> in <ph id="7">&amp;python;</ph> is like <bpt id="8">&lt;literal&gt;</bpt>require <bpt id="9">&lt;replaceable&gt;</bpt>module<ept id="9">&lt;/replaceable&gt;</ept>
          <ept id="8">&lt;/literal&gt;</ept> in <ph id="10">&amp;perl;</ph>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516768</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="24" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="close">&lt;/note&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516769</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="25" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="open">&lt;note id=&quot;compare.fromimport.java&quot; role=&quot;compare&quot; vendor=&quot;java&quot;&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516770</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="26" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph>
          <ph id="2">&amp;vs;</ph>
          <ph id="3">&amp;java;</ph>: <ph id="4">&amp;frommoduleimport;</ph>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516775</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="27" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;frommoduleimportstar;</ph> in <ph id="2">&amp;python;</ph> is like <bpt id="3">&lt;literal&gt;</bpt>import <bpt id="4">&lt;replaceable&gt;</bpt>module<ept id="4">&lt;/replaceable&gt;</ept>.*<ept id="3">&lt;/literal&gt;</ept> in <ph id="5">&amp;java;</ph>; <ph id="6">&amp;importmodule;</ph> in <ph id="7">&amp;python;</ph> is like <bpt id="8">&lt;literal&gt;</bpt>import <bpt id="9">&lt;replaceable&gt;</bpt>module<ept id="9">&lt;/replaceable&gt;</ept>
          <ept id="8">&lt;/literal&gt;</ept> in <ph id="10">&amp;java;</ph>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516776</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="28" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="close">&lt;/note&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516777</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="29" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;importmodule;</ph>
          <ph id="2">&amp;vs;</ph>
          <ph id="3">&amp;frommoduleimport;</ph>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516778</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="yes" id="30" reformat="yes" translate="yes" xml:space="default">
        <source>The <bpt id="1">&lt;filename class=&quot;headerfile&quot;&gt;</bpt>types<ept id="1">&lt;/filename&gt;</ept> module contains no methods; it just has attributes for each <ph id="2">&amp;python;</ph> object type.</source>
        <target/>
        <prop-group>
          <prop prop-type="entryid">1150875516779</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="31" reformat="yes" translate="yes" xml:space="default">
        <source>Note that the attribute, <ph id="1">&amp;functiontype;</ph>, must be qualified by the module name, <bpt id="2">&lt;filename class=&quot;headerfile&quot;&gt;</bpt>types<ept id="2">&lt;/filename&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516781</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="32" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;functiontype;</ph> by itself has not been defined in this namespace; it exists only in the context of <bpt id="2">&lt;filename class=&quot;headerfile&quot;&gt;</bpt>types<ept id="2">&lt;/filename&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516782</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="33" reformat="yes" translate="yes" xml:space="default">
        <source>This syntax imports the attribute <ph id="1">&amp;functiontype;</ph> from the <bpt id="2">&lt;filename class=&quot;headerfile&quot;&gt;</bpt>types<ept id="2">&lt;/filename&gt;</ept> module directly into the local namespace.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516783</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="34" reformat="yes" translate="yes" xml:space="default">
        <source>Now <ph id="1">&amp;functiontype;</ph> can be accessed directly, without reference to <bpt id="2">&lt;filename class=&quot;headerfile&quot;&gt;</bpt>types<ept id="2">&lt;/filename&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516784</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="35" reformat="yes" translate="yes" xml:space="default">
        <source>When should you use <ph id="1">&amp;frommoduleimport;</ph>?</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516785</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="36" reformat="yes" translate="yes" xml:space="default">
        <source>If you will be accessing attributes and methods often and don't want to type the module name over and over, use <ph id="1">&amp;frommoduleimport;</ph>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516786</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="37" reformat="yes" translate="yes" xml:space="default">
        <source>If you want to selectively import some attributes and methods but not others, use <ph id="1">&amp;frommoduleimport;</ph>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516787</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="38" reformat="yes" translate="yes" xml:space="default">
        <source>If the module contains attributes or functions with the same name as ones in your module, you must use <ph id="1">&amp;importmodule;</ph> to avoid name conflicts.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516788</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="39" reformat="yes" translate="yes" xml:space="default">
        <source>Other than that, it's just a matter of style, and you will see <ph id="1">&amp;python;</ph> code written both ways.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516789</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="40" reformat="yes" translate="yes" xml:space="default">
        <source>Use <bpt id="1">&lt;literal&gt;</bpt>from module import *<ept id="1">&lt;/literal&gt;</ept> sparingly, because it makes it difficult to determine where a particular function or attribute came from, and that makes debugging and refactoring more difficult.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516790</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="41" reformat="yes" translate="yes" xml:space="default">
        <source>Further Reading on Module Importing Techniques</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516791</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="42" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;effbot;</ph> has more to say on <bpt id="2">&lt;ulink url=&quot;&amp;url_effbot;import-confusion.htm&quot;&gt;</bpt>
          <ph id="3">&amp;importmodule;</ph>
          <ph id="4">&amp;vs;</ph>
          <ph id="5">&amp;frommoduleimport;</ph>
          <ept id="2">&lt;/ulink&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516792</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="43" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;pythontutorial;</ph> discusses advanced import techniques, including <bpt id="2">&lt;ulink url=&quot;&amp;url_pythontutorial;node8.html#SECTION008410000000000000000&quot;&gt;</bpt>
          <ph id="3">&amp;frommoduleimportstar;</ph>
          <ept id="2">&lt;/ulink&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516793</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="44" reformat="yes" translate="yes" xml:space="default">
        <source>Defining Classes</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516797</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="45" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph> is fully object-oriented:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516798</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="46" reformat="yes" translate="yes" xml:space="default">
        <source>you can define your own classes, inherit from your own or built-in classes, and instantiate the classes you've defined.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516799</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="47" reformat="yes" translate="yes" xml:space="default">
        <source>Defining a class in <ph id="1">&amp;python;</ph> is simple.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516800</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="48" reformat="yes" translate="yes" xml:space="default">
        <source>As with functions, there is no separate interface definition.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516801</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="49" reformat="yes" translate="yes" xml:space="default">
        <source>Just define the class and start coding.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516802</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="50" reformat="yes" translate="yes" xml:space="default">
        <source>A <ph id="1">&amp;python;</ph> class starts with the reserved word <ph id="2">&amp;class;</ph>, followed by the class name.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516803</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="51" reformat="yes" translate="yes" xml:space="default">
        <source>Technically, that's all that's required, since a class doesn't need to inherit from any other class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516804</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="52" reformat="yes" translate="yes" xml:space="default">
        <source>The Simplest <ph id="1">&amp;python;</ph> Class</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516805</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="53" reformat="yes" translate="yes" xml:space="default">
        <source>The name of this class is <bpt id="1">&lt;classname&gt;</bpt>Loaf<ept id="1">&lt;/classname&gt;</ept>, and it doesn't inherit from any other class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516806</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="54" reformat="yes" translate="yes" xml:space="default">
        <source>Class names are usually capitalized, <bpt id="1">&lt;classname&gt;</bpt>EachWordLikeThis<ept id="1">&lt;/classname&gt;</ept>, but this is only a convention, not a requirement.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516807</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="55" reformat="yes" translate="yes" xml:space="default">
        <source>This class doesn't define any methods or attributes, but syntactically, there needs to be something in the definition, so you use <ph id="1">&amp;pass;</ph>. This is a <ph id="2">&amp;python;</ph> reserved word that just means <bpt id="3">&lt;quote&gt;</bpt>move along, nothing to see here<ept id="3">&lt;/quote&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516808</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="56" reformat="yes" translate="yes" xml:space="default">
        <source>It's a statement that does nothing, and it's a good placeholder when you're stubbing out functions or classes.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516809</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="57" reformat="yes" translate="yes" xml:space="default">
        <source>You probably guessed this, but everything in a class is indented, just like the code within a function, <ph id="1">&amp;if;</ph> statement, <ph id="2">&amp;for;</ph> loop, and so forth.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516810</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="58" reformat="yes" translate="yes" xml:space="default">
        <source>The first thing not indented is not in the class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516811</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="59" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="open">&lt;note id=&quot;compare.pass.java&quot; role=&quot;compare&quot; vendor=&quot;java&quot;&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516812</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="60" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph>
          <ph id="2">&amp;vs;</ph>
          <ph id="3">&amp;java;</ph>: <ph id="4">&amp;pass;</ph>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516813</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="61" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;pass;</ph> statement in <ph id="2">&amp;python;</ph> is like an empty set of braces (<bpt id="3">&lt;literal&gt;</bpt>{}<ept id="3">&lt;/literal&gt;</ept>) in <ph id="4">&amp;java;</ph> or <ph id="5">&amp;c;</ph>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516814</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="62" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="close">&lt;/note&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516815</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="63" reformat="yes" translate="yes" xml:space="default">
        <source>Of course, realistically, most classes will be inherited from other classes, and they will define their own class methods and attributes.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516816</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="64" reformat="yes" translate="yes" xml:space="default">
        <source>But as you've just seen, there is nothing that a class absolutely must have, other than a name.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516817</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="65" reformat="yes" translate="yes" xml:space="default">
        <source>In particular, <ph id="1">&amp;cpp;</ph> programmers may find it odd that <ph id="2">&amp;python;</ph> classes don't have explicit constructors and destructors.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516818</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="66" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph> classes do have something similar to a constructor:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516819</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="67" reformat="yes" translate="yes" xml:space="default">
        <source>the <ph id="1">&amp;init;</ph> method.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516820</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="68" reformat="yes" translate="yes" xml:space="default">
        <source>Defining the <ph id="1">&amp;fileinfo_classname;</ph> Class</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516821</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="69" reformat="yes" translate="yes" xml:space="default">
        <source>In <ph id="1">&amp;python;</ph>, the ancestor of a class is simply listed in parentheses immediately after the class name.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516822</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="70" reformat="yes" translate="yes" xml:space="default">
        <source>So the <bpt id="1">&lt;classname&gt;</bpt>FileInfo<ept id="1">&lt;/classname&gt;</ept> class is inherited from the <bpt id="2">&lt;classname&gt;</bpt>UserDict<ept id="2">&lt;/classname&gt;</ept> class (which was <bpt id="3">&lt;link linkend=&quot;fileinfo.fromimport&quot;&gt;</bpt>imported from the <bpt id="4">&lt;filename class=&quot;headerfile&quot;&gt;</bpt>UserDict<ept id="4">&lt;/filename&gt;</ept> module<ept id="3">&lt;/link&gt;</ept>).</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516823</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="71" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;classname&gt;</bpt>UserDict<ept id="1">&lt;/classname&gt;</ept> is a class that acts like a dictionary, allowing you to essentially subclass the dictionary datatype and add your own behavior.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516824</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="72" reformat="yes" translate="yes" xml:space="default">
        <source>(There are similar classes <bpt id="1">&lt;classname&gt;</bpt>UserList<ept id="1">&lt;/classname&gt;</ept> and <bpt id="2">&lt;classname&gt;</bpt>UserString<ept id="2">&lt;/classname&gt;</ept> which allow you to subclass lists and strings.) There is a bit of black magic behind this, which you will demystify later in this chapter when you explore the <bpt id="3">&lt;classname&gt;</bpt>UserDict<ept id="3">&lt;/classname&gt;</ept> class in more depth.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516825</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="73" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="open">&lt;note id=&quot;compare.extends.java&quot; role=&quot;compare&quot; vendor=&quot;java&quot;&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516826</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="74" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph>
          <ph id="2">&amp;vs;</ph>
          <ph id="3">&amp;java;</ph>: Ancestors</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516827</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="75" reformat="yes" translate="yes" xml:space="default">
        <source>In <ph id="1">&amp;python;</ph>, the ancestor of a class is simply listed in parentheses immediately after the class name.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516828</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="76" reformat="yes" translate="yes" xml:space="default">
        <source>There is no special keyword like <bpt id="1">&lt;literal&gt;</bpt>extends<ept id="1">&lt;/literal&gt;</ept> in <ph id="2">&amp;java;</ph>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516829</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="77" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="close">&lt;/note&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516830</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="78" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph> supports multiple inheritance.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516831</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="79" reformat="yes" translate="yes" xml:space="default">
        <source>In the parentheses following the class name, you can list as many ancestor classes as you like, separated by commas.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516832</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="80" reformat="yes" translate="yes" xml:space="default">
        <source>Initializing and Coding Classes</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516833</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="81" reformat="yes" translate="yes" xml:space="default">
        <source>This example shows the initialization of the <ph id="1">&amp;fileinfo_classname;</ph> class using the <ph id="2">&amp;init;</ph> method.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516834</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="82" reformat="yes" translate="yes" xml:space="default">
        <source>Initializing the <ph id="1">&amp;fileinfo_classname;</ph> Class</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516835</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="83" reformat="yes" translate="yes" xml:space="default">
        <source>Classes can (and <bpt id="1">&lt;link linkend=&quot;tip.docstring&quot;&gt;</bpt>should<ept id="1">&lt;/link&gt;</ept>) have <ph id="2">&amp;docstring;</ph>s too, just like modules and functions.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516836</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="84" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;init;</ph> is called immediately after an instance of the class is created.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516837</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="85" reformat="yes" translate="yes" xml:space="default">
        <source>It would be tempting but incorrect to call this the constructor of the class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516840</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="86" reformat="yes" translate="yes" xml:space="default">
        <source>It's tempting, because it looks like a constructor (by convention, <ph id="1">&amp;init;</ph> is the first method defined for the class), acts like one (it's the first piece of code executed in a newly created instance of the class), and even sounds like one (<bpt id="2">&lt;quote&gt;</bpt>init<ept id="2">&lt;/quote&gt;</ept> certainly suggests a constructor-ish nature).</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516841</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="87" reformat="yes" translate="yes" xml:space="default">
        <source>Incorrect, because the object has already been constructed by the time <ph id="1">&amp;init;</ph> is called, and you already have a valid reference to the new instance of the class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516842</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="88" reformat="yes" translate="yes" xml:space="default">
        <source>But <ph id="1">&amp;init;</ph> is the closest thing you're going to get to a constructor in <ph id="2">&amp;python;</ph>, and it fills much the same role.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516843</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="89" reformat="yes" translate="yes" xml:space="default">
        <source>The first argument of every class method, including <ph id="1">&amp;init;</ph>, is always a reference to the current instance of the class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516844</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="90" reformat="yes" translate="yes" xml:space="default">
        <source>By convention, this argument is always named <ph id="1">&amp;self;</ph>. In the <ph id="2">&amp;init;</ph> method, <ph id="3">&amp;self;</ph> refers to the newly created object; in other class methods, it refers to the instance whose method was called.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516845</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="91" reformat="yes" translate="yes" xml:space="default">
        <source>Although you need to specify <ph id="1">&amp;self;</ph> explicitly when defining the method, you do <bpt id="2">&lt;emphasis&gt;</bpt>not<ept id="2">&lt;/emphasis&gt;</ept> specify it when calling the method; <ph id="3">&amp;python;</ph> will add it for you automatically.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516846</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="92" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;init;</ph> methods can take any number of arguments, and just like functions, the arguments can be defined with default values, making them optional to the caller.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516847</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="93" reformat="yes" translate="yes" xml:space="default">
        <source>In this case, <bpt id="1">&lt;varname&gt;</bpt>filename<ept id="1">&lt;/varname&gt;</ept> has a default value of <ph id="2">&amp;none;</ph>, which is the <ph id="3">&amp;python;</ph> null value.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516848</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="94" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="open">&lt;note id=&quot;compare.self.java&quot; role=&quot;compare&quot; vendor=&quot;java&quot;&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516849</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="95" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph>
          <ph id="2">&amp;vs;</ph>
          <ph id="3">&amp;java;</ph>: <ph id="4">&amp;self;</ph>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516850</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="96" reformat="yes" translate="yes" xml:space="default">
        <source>By convention, the first argument of any <ph id="1">&amp;python;</ph> class method (the reference to the current instance) is called <ph id="2">&amp;self;</ph>. This argument fills the role of the reserved word <ph id="3">&amp;this;</ph> in <ph id="4">&amp;cpp;</ph> or <ph id="5">&amp;java;</ph>, but <ph id="6">&amp;self;</ph> is not a reserved word in <ph id="7">&amp;python;</ph>, merely a naming convention.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516851</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="97" reformat="yes" translate="yes" xml:space="default">
        <source>Nonetheless, please don't call it anything but <ph id="1">&amp;self;</ph>; this is a very strong convention.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516852</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="98" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="close">&lt;/note&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516853</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="99" reformat="yes" translate="yes" xml:space="default">
        <source>Coding the <ph id="1">&amp;fileinfo_classname;</ph> Class</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516854</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="100" reformat="yes" translate="yes" xml:space="default">
        <source>Some pseudo-object-oriented languages like <ph id="1">&amp;powerbuilder;</ph> have a concept of <bpt id="2">&lt;quote&gt;</bpt>extending<ept id="2">&lt;/quote&gt;</ept> constructors and other events, where the ancestor's method is called automatically before the descendant's method is executed.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516855</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="101" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph> does not do this; you must always explicitly call the appropriate method in the ancestor class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516856</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="102" reformat="yes" translate="yes" xml:space="default">
        <source>I told you that this class acts like a dictionary, and here is the first sign of it.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516858</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="103" reformat="yes" translate="yes" xml:space="default">
        <source>You're assigning the argument <bpt id="1">&lt;varname&gt;</bpt>filename<ept id="1">&lt;/varname&gt;</ept> as the value of this object's <bpt id="2">&lt;literal&gt;</bpt>name<ept id="2">&lt;/literal&gt;</ept> key.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516859</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="104" reformat="yes" translate="yes" xml:space="default">
        <source>Note that the <ph id="1">&amp;init;</ph> method never returns a value.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516860</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="105" reformat="yes" translate="yes" xml:space="default">
        <source>Knowing When to Use <ph id="1">&amp;self;</ph> and <ph id="2">&amp;init;</ph>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516861</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="106" reformat="yes" translate="yes" xml:space="default">
        <source>When defining your class methods, you <bpt id="1">&lt;emphasis&gt;</bpt>must<ept id="1">&lt;/emphasis&gt;</ept> explicitly list <ph id="2">&amp;self;</ph> as the first argument for each method, including <ph id="3">&amp;init;</ph>. When you call a method of an ancestor class from within your class, you <bpt id="4">&lt;emphasis&gt;</bpt>must<ept id="4">&lt;/emphasis&gt;</ept> include the <ph id="5">&amp;self;</ph> argument.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516862</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="107" reformat="yes" translate="yes" xml:space="default">
        <source>But when you call your class method from outside, you do not specify anything for the <ph id="1">&amp;self;</ph> argument; you skip it entirely, and <ph id="2">&amp;python;</ph> automatically adds the instance reference for you.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516863</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="108" reformat="yes" translate="yes" xml:space="default">
        <source>I am aware that this is confusing at first; it's not really inconsistent, but it may appear inconsistent because it relies on a distinction (between bound and unbound methods) that you don't know about yet.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516864</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="109" reformat="yes" translate="yes" xml:space="default">
        <source>Whew.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516865</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="110" reformat="yes" translate="yes" xml:space="default">
        <source>I realize that's a lot to absorb, but you'll get the hang of it.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516866</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="111" reformat="yes" translate="yes" xml:space="default">
        <source>All <ph id="1">&amp;python;</ph> classes work the same way, so once you learn one, you've learned them all.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516867</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="112" reformat="yes" translate="yes" xml:space="default">
        <source>If you forget everything else, remember this one thing, because I promise it will trip you up:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516868</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="113" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="open">&lt;note id=&quot;tip.initoptional&quot;&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516869</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="114" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;init;</ph> Methods</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516870</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="115" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;init;</ph> methods are optional, but when you define one, you must remember to explicitly call the ancestor's <ph id="2">&amp;init;</ph> method (if it defines one).</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516871</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="116" reformat="yes" translate="yes" xml:space="default">
        <source>This is more generally true:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516872</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="117" reformat="yes" translate="yes" xml:space="default">
        <source>whenever a descendant wants to extend the behavior of the ancestor, the descendant method must explicitly call the ancestor method at the proper time, with the proper arguments.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516876</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="118" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="close">&lt;/note&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516877</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="119" reformat="yes" translate="yes" xml:space="default">
        <source>Further Reading on <ph id="1">&amp;python;</ph> Classes</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516878</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="120" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;learningtoprogram;</ph> has a gentler <bpt id="2">&lt;ulink url=&quot;&amp;url_learningtoprogram;tutclass.htm&quot;&gt;</bpt>introduction to classes<ept id="2">&lt;/ulink&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516879</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="121" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;howtothink;</ph> shows how to <bpt id="2">&lt;ulink url=&quot;&amp;url_howtothink;chap12.htm&quot;&gt;</bpt>use classes to model compound datatypes<ept id="2">&lt;/ulink&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516880</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="122" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;pythontutorial;</ph> has an in-depth look at <bpt id="2">&lt;ulink url=&quot;&amp;url_pythontutorial;node11.html&quot;&gt;</bpt>classes, namespaces, and inheritance<ept id="2">&lt;/ulink&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516881</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="123" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;pythonknowledgebase;</ph> answers <bpt id="2">&lt;ulink url=&quot;&amp;url_pythonknowledgebase;index.phtml/fid/242&quot;&gt;</bpt>common questions about classes<ept id="2">&lt;/ulink&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516882</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="124" reformat="yes" translate="yes" xml:space="default">
        <source>Instantiating Classes</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516883</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="125" reformat="yes" translate="yes" xml:space="default">
        <source>Instantiating classes in <ph id="1">&amp;python;</ph> is straightforward.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516884</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="126" reformat="yes" translate="yes" xml:space="default">
        <source>To instantiate a class, simply call the class as if it were a function, passing the arguments that the <ph id="1">&amp;init;</ph> method defines.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516885</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="127" reformat="yes" translate="yes" xml:space="default">
        <source>The return value will be the newly created object.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516886</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="128" reformat="yes" translate="yes" xml:space="default">
        <source>Creating a <bpt id="1">&lt;classname&gt;</bpt>FileInfo<ept id="1">&lt;/classname&gt;</ept> Instance</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516887</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="129" reformat="yes" translate="yes" xml:space="default">
        <source>You are creating an instance of the <bpt id="1">&lt;classname&gt;</bpt>FileInfo<ept id="1">&lt;/classname&gt;</ept> class (defined in the <ph id="2">&amp;fileinfo_modulename;</ph> module) and assigning the newly created instance to the variable <bpt id="3">&lt;varname&gt;</bpt>f<ept id="3">&lt;/varname&gt;</ept>. You are passing one parameter, <bpt id="4">&lt;literal&gt;</bpt>/music/_singles/kairo.mp3<ept id="4">&lt;/literal&gt;</ept>, which will end up as the <bpt id="5">&lt;varname&gt;</bpt>filename<ept id="5">&lt;/varname&gt;</ept> argument in <bpt id="6">&lt;classname&gt;</bpt>FileInfo<ept id="6">&lt;/classname&gt;</ept>'s <ph id="7">&amp;init;</ph> method.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516888</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="130" reformat="yes" translate="yes" xml:space="default">
        <source>Every class instance has a built-in attribute, <ph id="1">&amp;classattr;</ph>, which is the object's class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516889</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="131" reformat="yes" translate="yes" xml:space="default">
        <source>(Note that the representation of this includes the physical address of the instance on my machine; your representation will be different.) <ph id="1">&amp;java;</ph> programmers may be familiar with the <bpt id="2">&lt;classname&gt;</bpt>Class<ept id="2">&lt;/classname&gt;</ept> class, which contains methods like <bpt id="3">&lt;function&gt;</bpt>getName<ept id="3">&lt;/function&gt;</ept> and <bpt id="4">&lt;function&gt;</bpt>getSuperclass<ept id="4">&lt;/function&gt;</ept> to get metadata information about an object.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516890</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="132" reformat="yes" translate="yes" xml:space="default">
        <source>In <ph id="1">&amp;python;</ph>, this kind of metadata is available directly on the object itself through attributes like <ph id="2">&amp;classattr;</ph>, <bpt id="3">&lt;literal&gt;</bpt>__name__<ept id="3">&lt;/literal&gt;</ept>, and <bpt id="4">&lt;literal&gt;</bpt>__bases__<ept id="4">&lt;/literal&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516891</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="133" reformat="yes" translate="yes" xml:space="default">
        <source>You can access the instance's <ph id="1">&amp;docstring;</ph> just as with a function or a module.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516892</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="134" reformat="yes" translate="yes" xml:space="default">
        <source>All instances of a class share the same <ph id="1">&amp;docstring;</ph>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516893</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="135" reformat="yes" translate="yes" xml:space="default">
        <source>Remember when the <ph id="1">&amp;init;</ph> method <bpt id="2">&lt;link linkend=&quot;fileinfo.class.example&quot;&gt;</bpt>assigned its <bpt id="3">&lt;varname&gt;</bpt>filename<ept id="3">&lt;/varname&gt;</ept> argument to <bpt id="4">&lt;literal&gt;</bpt>self[&quot;name&quot;]<ept id="4">&lt;/literal&gt;</ept>
          <ept id="2">&lt;/link&gt;</ept>?</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516894</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="136" reformat="yes" translate="yes" xml:space="default">
        <source>Well, here's the result.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516899</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="137" reformat="yes" translate="yes" xml:space="default">
        <source>The arguments you pass when you create the class instance get sent right along to the <ph id="1">&amp;init;</ph> method (along with the object reference, <ph id="2">&amp;self;</ph>, which <ph id="3">&amp;python;</ph> adds for free).</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516900</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="138" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="open">&lt;note id=&quot;compare.new.java&quot; role=&quot;compare&quot; vendor=&quot;java&quot;&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516901</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="139" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph>
          <ph id="2">&amp;vs;</ph>
          <ph id="3">&amp;java;</ph>: Instantiating Classes</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516902</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="140" reformat="yes" translate="yes" xml:space="default">
        <source>In <ph id="1">&amp;python;</ph>, simply call a class as if it were a function to create a new instance of the class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516903</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="141" reformat="yes" translate="yes" xml:space="default">
        <source>There is no explicit <ph id="1">&amp;new;</ph> operator like <ph id="2">&amp;cpp;</ph> or <ph id="3">&amp;java;</ph>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516904</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="142" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="close">&lt;/note&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516905</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="143" reformat="yes" translate="yes" xml:space="default">
        <source>Garbage Collection</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516906</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="144" reformat="yes" translate="yes" xml:space="default">
        <source>If creating new instances is easy, destroying them is even easier.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516907</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="145" reformat="yes" translate="yes" xml:space="default">
        <source>In general, there is no need to explicitly free instances, because they are freed automatically when the variables assigned to them go out of scope.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516908</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="146" reformat="yes" translate="yes" xml:space="default">
        <source>Memory leaks are rare in <ph id="1">&amp;python;</ph>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516910</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="147" reformat="yes" translate="yes" xml:space="default">
        <source>Trying to Implement a Memory Leak</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516911</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="148" reformat="yes" translate="yes" xml:space="default">
        <source>Every time the <bpt id="1">&lt;function&gt;</bpt>leakmem<ept id="1">&lt;/function&gt;</ept> function is called, you are creating an instance of <bpt id="2">&lt;classname&gt;</bpt>FileInfo<ept id="2">&lt;/classname&gt;</ept> and assigning it to the variable <bpt id="3">&lt;varname&gt;</bpt>f<ept id="3">&lt;/varname&gt;</ept>, which is a local variable within the function.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516912</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="149" reformat="yes" translate="yes" xml:space="default">
        <source>Then the function ends without ever freeing <bpt id="1">&lt;varname&gt;</bpt>f<ept id="1">&lt;/varname&gt;</ept>, so you would expect a memory leak, but you would be wrong.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516913</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="150" reformat="yes" translate="yes" xml:space="default">
        <source>When the function ends, the local variable <bpt id="1">&lt;varname&gt;</bpt>f<ept id="1">&lt;/varname&gt;</ept> goes out of scope.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516914</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="151" reformat="yes" translate="yes" xml:space="default">
        <source>At this point, there are no longer any references to the newly created instance of <bpt id="1">&lt;classname&gt;</bpt>FileInfo<ept id="1">&lt;/classname&gt;</ept> (since you never assigned it to anything other than <bpt id="2">&lt;varname&gt;</bpt>f<ept id="2">&lt;/varname&gt;</ept>), so <ph id="3">&amp;python;</ph> destroys the instance for us.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516915</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="152" reformat="yes" translate="yes" xml:space="default">
        <source>No matter how many times you call the <bpt id="1">&lt;function&gt;</bpt>leakmem<ept id="1">&lt;/function&gt;</ept> function, it will never leak memory, because every time, <ph id="2">&amp;python;</ph> will destroy the newly created <ph id="3">&amp;fileinfo_classname;</ph> class before returning from <bpt id="4">&lt;function&gt;</bpt>leakmem<ept id="4">&lt;/function&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516916</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="153" reformat="yes" translate="yes" xml:space="default">
        <source>The technical term for this form of garbage collection is <bpt id="1">&lt;quote&gt;</bpt>reference counting<ept id="1">&lt;/quote&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516917</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="154" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph> keeps a list of references to every instance created.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516918</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="155" reformat="yes" translate="yes" xml:space="default">
        <source>In the above example, there was only one reference to the <ph id="1">&amp;fileinfo_classname;</ph> instance:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516919</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="156" reformat="yes" translate="yes" xml:space="default">
        <source>the local variable <bpt id="1">&lt;varname&gt;</bpt>f<ept id="1">&lt;/varname&gt;</ept>. When the function ends, the variable <bpt id="2">&lt;varname&gt;</bpt>f<ept id="2">&lt;/varname&gt;</ept> goes out of scope, so the reference count drops to <ph id="3">&amp;zero;</ph>, and <ph id="4">&amp;python;</ph> destroys the instance automatically.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516920</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="157" reformat="yes" translate="yes" xml:space="default">
        <source>In previous versions of <ph id="1">&amp;python;</ph>, there were situations where reference counting failed, and <ph id="2">&amp;python;</ph> couldn't clean up after you.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516921</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="158" reformat="yes" translate="yes" xml:space="default">
        <source>If you created two instances that referenced each other (for instance, a doubly-linked list, where each node has a pointer to the previous and next node in the list), neither instance would ever be destroyed automatically because <ph id="1">&amp;python;</ph> (correctly) believed that there is always a reference to each instance.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516922</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="159" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph> 2.0 has an additional form of garbage collection called <bpt id="2">&lt;quote&gt;</bpt>mark-and-sweep<ept id="2">&lt;/quote&gt;</ept> which is smart enough to notice this virtual gridlock and clean up circular references correctly.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516923</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="160" reformat="yes" translate="yes" xml:space="default">
        <source>As a former philosophy major, it disturbs me to think that things disappear when no one is looking at them, but that's exactly what happens in <ph id="1">&amp;python;</ph>. In general, you can simply forget about memory management and let <ph id="2">&amp;python;</ph> clean up after you.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516924</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="161" reformat="yes" translate="yes" xml:space="default">
        <source>Further Reading on Garbage Collection</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516925</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="162" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;pythonlibraryreference;</ph> summarizes <bpt id="2">&lt;ulink url=&quot;&amp;url_pythonlibraryreference;specialattrs.html&quot;&gt;</bpt>built-in attributes like <ph id="3">&amp;classattr;</ph>
          <ept id="2">&lt;/ulink&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516926</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="163" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;pythonlibraryreference;</ph> documents the <bpt id="2">&lt;ulink url=&quot;&amp;url_pythonlibraryreference;module-gc.html&quot;&gt;</bpt>
          <bpt id="3">&lt;filename class=&quot;headerfile&quot;&gt;</bpt>gc<ept id="3">&lt;/filename&gt;</ept> module<ept id="2">&lt;/ulink&gt;</ept>, which gives you low-level control over <ph id="4">&amp;python;</ph>'s garbage collection.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516927</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="164" reformat="yes" translate="yes" xml:space="default">
        <source>Exploring <ph id="1">&amp;userdict_classname;</ph>: A Wrapper Class</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516928</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="165" reformat="yes" translate="yes" xml:space="default">
        <source>As you've seen, <ph id="1">&amp;fileinfo_classname;</ph> is a class that acts like a dictionary.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516929</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="166" reformat="yes" translate="yes" xml:space="default">
        <source>To explore this further, let's look at the <ph id="1">&amp;userdict_classname;</ph> class in the <ph id="2">&amp;userdict;</ph> module, which is the ancestor of the <ph id="3">&amp;fileinfo_classname;</ph> class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516930</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="167" reformat="yes" translate="yes" xml:space="default">
        <source>This is nothing special; the class is written in <ph id="1">&amp;python;</ph> and stored in a <bpt id="2">&lt;literal&gt;</bpt>.py<ept id="2">&lt;/literal&gt;</ept> file, just like any other <ph id="3">&amp;python;</ph> code.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516931</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="168" reformat="yes" translate="yes" xml:space="default">
        <source>In particular, it's stored in the <bpt id="1">&lt;filename class=&quot;directory&quot;&gt;</bpt>lib<ept id="1">&lt;/filename&gt;</ept> directory in your <ph id="2">&amp;python;</ph> installation.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516932</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="169" reformat="yes" translate="yes" xml:space="default">
        <source>In the <ph id="1">&amp;activepython;</ph>
          <ph id="2">&amp;ide;</ph> on <ph id="3">&amp;windows;</ph>, you can quickly open any module in your library path by selecting <it id="4" pos="open">&lt;menuchoice&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516933</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="170" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="open">&lt;shortcut&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516934</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="171" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="open">&lt;keycombo&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516935</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="172" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;keycap&gt;</bpt>Ctrl<ept id="1">&lt;/keycap&gt;</ept>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516936</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="173" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;keysym&gt;</bpt>L<ept id="1">&lt;/keysym&gt;</ept>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516937</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="174" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="close">&lt;/keycombo&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516938</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="175" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="close">&lt;/shortcut&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516939</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="176" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;guimenu&gt;</bpt>File<ept id="1">&lt;/guimenu&gt;</ept>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516940</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="177" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;guimenuitem&gt;</bpt>
          <bpt id="2">&lt;accel&gt;</bpt>L<ept id="2">&lt;/accel&gt;</ept>ocate...<ept id="1">&lt;/guimenuitem&gt;</ept>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516941</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="178" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="close">&lt;/menuchoice&gt;</it>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516942</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="179" reformat="yes" translate="yes" xml:space="default">
        <source>Defining the <ph id="1">&amp;userdict_classname;</ph> Class</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516943</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="180" reformat="yes" translate="yes" xml:space="default">
        <source>Note that <ph id="1">&amp;userdict_classname;</ph> is a base class, not inherited from any other class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516944</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="181" reformat="yes" translate="yes" xml:space="default">
        <source>This is the <ph id="1">&amp;init;</ph> method that you <bpt id="2">&lt;link linkend=&quot;fileinfo.class.example&quot;&gt;</bpt>overrode in the <ph id="3">&amp;fileinfo_classname;</ph> class<ept id="2">&lt;/link&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516945</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="182" reformat="yes" translate="yes" xml:space="default">
        <source>Note that the argument list in this ancestor class is different than the descendant.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516946</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="183" reformat="yes" translate="yes" xml:space="default">
        <source>That's okay; each subclass can have its own set of arguments, as long as it calls the ancestor with the correct arguments.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516947</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="184" reformat="yes" translate="yes" xml:space="default">
        <source>Here the ancestor class has a way to define initial values (by passing a dictionary in the <bpt id="1">&lt;varname&gt;</bpt>dict<ept id="1">&lt;/varname&gt;</ept> argument) which the <ph id="2">&amp;fileinfo_classname;</ph> does not use.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516948</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="185" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph> supports data attributes (called <bpt id="2">&lt;quote&gt;</bpt>instance variables<ept id="2">&lt;/quote&gt;</ept> in <ph id="3">&amp;java;</ph> and <ph id="4">&amp;powerbuilder;</ph>, and <bpt id="5">&lt;quote&gt;</bpt>member variables<ept id="5">&lt;/quote&gt;</ept> in <ph id="6">&amp;cpp;</ph>). Data attributes are pieces of data held by a specific instance of a class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516949</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="186" reformat="yes" translate="yes" xml:space="default">
        <source>In this case, each instance of <ph id="1">&amp;userdict_classname;</ph> will have a data attribute <bpt id="2">&lt;varname&gt;</bpt>data<ept id="2">&lt;/varname&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516951</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="187" reformat="yes" translate="yes" xml:space="default">
        <source>To reference this attribute from code outside the class, you qualify it with the instance name, <bpt id="1">&lt;literal&gt;</bpt>
          <bpt id="2">&lt;replaceable&gt;</bpt>instance<ept id="2">&lt;/replaceable&gt;</ept>.data<ept id="1">&lt;/literal&gt;</ept>, in the same way that you qualify a function with its module name.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516952</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="188" reformat="yes" translate="yes" xml:space="default">
        <source>To reference a data attribute from within the class, you use <ph id="1">&amp;self;</ph> as the qualifier.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516953</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="189" reformat="yes" translate="yes" xml:space="default">
        <source>By convention, all data attributes are initialized to reasonable values in the <ph id="1">&amp;init;</ph> method.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516954</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="190" reformat="yes" translate="yes" xml:space="default">
        <source>However, this is not required, since data attributes, like local variables, <bpt id="1">&lt;link linkend=&quot;odbchelper.vardef&quot;&gt;</bpt>spring into existence<ept id="1">&lt;/link&gt;</ept> when they are first assigned a value.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516955</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="191" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;update;</ph> method is a dictionary duplicator:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516956</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="192" reformat="yes" translate="yes" xml:space="default">
        <source>it copies all the keys and values from one dictionary to another.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516957</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="193" reformat="yes" translate="yes" xml:space="default">
        <source>This does <bpt id="1">&lt;emphasis&gt;</bpt>not<ept id="1">&lt;/emphasis&gt;</ept> clear the target dictionary first; if the target dictionary already has some keys, the ones from the source dictionary will be overwritten, but others will be left untouched.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516958</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="194" reformat="yes" translate="yes" xml:space="default">
        <source>Think of <ph id="1">&amp;update;</ph> as a merge function, not a copy function.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516959</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="195" reformat="yes" translate="yes" xml:space="default">
        <source>This is a syntax you may not have seen before (I haven't used it in the examples in this book).</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516960</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="196" reformat="yes" translate="yes" xml:space="default">
        <source>It's an <ph id="1">&amp;if;</ph> statement, but instead of having an indented block starting on the next line, there is just a single statement on the same line, after the colon.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516961</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="197" reformat="yes" translate="yes" xml:space="default">
        <source>This is perfectly legal syntax, which is just a shortcut you can use when you have only one statement in a block.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516962</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="198" reformat="yes" translate="yes" xml:space="default">
        <source>(It's like specifying a single statement without braces in <ph id="1">&amp;cpp;</ph>.) You can use this syntax, or you can have indented code on subsequent lines, but you can't do both for the same block.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516963</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="199" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="open">&lt;note id=&quot;compare.overloading&quot; role=&quot;compare&quot; vendor=&quot;java&quot;&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516964</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="200" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph>
          <ph id="2">&amp;vs;</ph>
          <ph id="3">&amp;java;</ph>: Function Overloading</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516965</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="201" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;java;</ph> and <ph id="2">&amp;powerbuilder;</ph> support function overloading by argument list, <ph id="3">&amp;ie;</ph> one class can have multiple methods with the same name but a different number of arguments, or arguments of different types.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516966</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="202" reformat="yes" translate="yes" xml:space="default">
        <source>Other languages (most notably <ph id="1">&amp;plsql;</ph>) even support function overloading by argument name; <ph id="2">&amp;ie;</ph> one class can have multiple methods with the same name and the same number of arguments of the same type but different argument names.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516967</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="203" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph> supports neither of these; it has no form of function overloading whatsoever.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516968</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="204" reformat="yes" translate="yes" xml:space="default">
        <source>Methods are defined solely by their name, and there can be only one method per class with a given name.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516969</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="205" reformat="yes" translate="yes" xml:space="default">
        <source>So if a descendant class has an <ph id="1">&amp;init;</ph> method, it <bpt id="2">&lt;emphasis&gt;</bpt>always<ept id="2">&lt;/emphasis&gt;</ept> overrides the ancestor <ph id="3">&amp;init;</ph> method, even if the descendant defines it with a different argument list.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516970</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="206" reformat="yes" translate="yes" xml:space="default">
        <source>And the same rule applies to any other method.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516971</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="207" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="close">&lt;/note&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516972</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="208" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="open">&lt;note id=&quot;fileinfo.derivedclasses&quot;&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516973</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="209" reformat="yes" translate="yes" xml:space="default">
        <source>Guido, the original author of <ph id="1">&amp;python;</ph>, explains method overriding this way:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516974</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="210" reformat="yes" translate="yes" xml:space="default">
        <source>&quot;Derived classes may override methods of their base classes.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516975</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="211" reformat="yes" translate="yes" xml:space="default">
        <source>Because methods have no special privileges when calling other methods of the same object, a method of a base class that calls another method defined in the same base class, may in fact end up calling a method of a derived class that overrides it.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516976</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="212" reformat="yes" translate="yes" xml:space="default">
        <source>(For <ph id="1">&amp;cpp;</ph> programmers:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516977</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="213" reformat="yes" translate="yes" xml:space="default">
        <source>all methods in <ph id="1">&amp;python;</ph> are effectively virtual.)&quot; If that doesn't make sense to you (it confuses the hell out of me), feel free to ignore it.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516978</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="214" reformat="yes" translate="yes" xml:space="default">
        <source>I just thought I'd pass it along.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516979</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="215" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="close">&lt;/note&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516984</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="216" reformat="yes" translate="yes" xml:space="default">
        <source>Always assign an initial value to all of an instance's data attributes in the <ph id="1">&amp;init;</ph> method.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516985</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="217" reformat="yes" translate="yes" xml:space="default">
        <source>It will save you hours of debugging later, tracking down <bpt id="1">&lt;classname&gt;</bpt>AttributeError<ept id="1">&lt;/classname&gt;</ept> exceptions because you're referencing uninitialized (and therefore non-existent) attributes.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516986</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="218" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;userdict_classname;</ph> Normal Methods</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516987</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="219" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;clear;</ph> is a normal class method; it is publicly available to be called by anyone at any time.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516988</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="220" reformat="yes" translate="yes" xml:space="default">
        <source>Notice that <ph id="1">&amp;clear;</ph>, like all class methods, has <ph id="2">&amp;self;</ph> as its first argument.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516989</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="221" reformat="yes" translate="yes" xml:space="default">
        <source>(Remember that you don't include <ph id="1">&amp;self;</ph> when you call the method; it's something that <ph id="2">&amp;python;</ph> adds for you.) Also note the basic technique of this wrapper class:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516990</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="222" reformat="yes" translate="yes" xml:space="default">
        <source>store a real dictionary (<bpt id="1">&lt;varname&gt;</bpt>data<ept id="1">&lt;/varname&gt;</ept>) as a data attribute, define all the methods that a real dictionary has, and have each class method redirect to the corresponding method on the real dictionary.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516991</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="223" reformat="yes" translate="yes" xml:space="default">
        <source>(In case you'd forgotten, a dictionary's <ph id="1">&amp;clear;</ph> method <bpt id="2">&lt;link linkend=&quot;odbchelper.dict.del&quot;&gt;</bpt>deletes all of its keys<ept id="2">&lt;/link&gt;</ept> and their associated values.)</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516992</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="224" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;copy;</ph> method of a real dictionary returns a new dictionary that is an exact duplicate of the original (all the same key-value pairs).</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516993</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="225" reformat="yes" translate="yes" xml:space="default">
        <source>But <ph id="1">&amp;userdict_classname;</ph> can't simply redirect to <bpt id="2">&lt;function&gt;</bpt>self.data.copy<ept id="2">&lt;/function&gt;</ept>, because that method returns a real dictionary, and what you want is to return a new instance that is the same class as <ph id="3">&amp;self;</ph>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516994</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="226" reformat="yes" translate="yes" xml:space="default">
        <source>You use the <ph id="1">&amp;classattr;</ph> attribute to see if <ph id="2">&amp;self;</ph> is a <ph id="3">&amp;userdict_classname;</ph>; if so, you're golden, because you know how to copy a <ph id="4">&amp;userdict_classname;</ph>: just create a new <ph id="5">&amp;userdict_classname;</ph> and give it the real dictionary that you've squirreled away in <bpt id="6">&lt;varname&gt;</bpt>self.data<ept id="6">&lt;/varname&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516995</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="227" reformat="yes" translate="yes" xml:space="default">
        <source>Then you immediately return the new <ph id="1">&amp;userdict_classname;</ph> you don't even get to the <bpt id="2">&lt;literal&gt;</bpt>import copy<ept id="2">&lt;/literal&gt;</ept> on the next line.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516996</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="228" reformat="yes" translate="yes" xml:space="default">
        <source>If <bpt id="1">&lt;literal&gt;</bpt>
          <ph id="2">&amp;self;</ph>.<ph id="3">&amp;classattr;</ph>
          <ept id="1">&lt;/literal&gt;</ept> is not <ph id="4">&amp;userdict_classname;</ph>, then <ph id="5">&amp;self;</ph> must be some subclass of <ph id="6">&amp;userdict_classname;</ph> (like maybe <ph id="7">&amp;fileinfo_classname;</ph>), in which case life gets trickier.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516997</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="229" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;userdict_classname;</ph> doesn't know how to make an exact copy of one of its descendants; there could, for instance, be other data attributes defined in the subclass, so you would need to iterate through them and make sure to copy all of them.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516998</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="230" reformat="yes" translate="yes" xml:space="default">
        <source>Luckily, <ph id="1">&amp;python;</ph> comes with a module to do exactly this, and it's called <ph id="2">&amp;copy;</ph>. I won't go into the details here (though it's a wicked cool module, if you're ever inclined to dive into it on your own).</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875516999</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="231" reformat="yes" translate="yes" xml:space="default">
        <source>Suffice it to say that <ph id="1">&amp;copy;</ph> can copy arbitrary <ph id="2">&amp;python;</ph> objects, and that's how you're using it here.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517000</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="232" reformat="yes" translate="yes" xml:space="default">
        <source>The rest of the methods are straightforward, redirecting the calls to the built-in methods on <bpt id="1">&lt;varname&gt;</bpt>self.data<ept id="1">&lt;/varname&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517001</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="233" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="open">&lt;note&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517002</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="234" reformat="yes" translate="yes" xml:space="default">
        <source>Historical Note</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517003</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="235" reformat="yes" translate="yes" xml:space="default">
        <source>In versions of <ph id="1">&amp;python;</ph> prior to 2.2, you could not directly subclass built-in datatypes like strings, lists, and dictionaries.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517004</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="236" reformat="yes" translate="yes" xml:space="default">
        <source>To compensate for this, <ph id="1">&amp;python;</ph> comes with wrapper classes that mimic the behavior of these built-in datatypes:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517005</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="237" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;classname&gt;</bpt>UserString<ept id="1">&lt;/classname&gt;</ept>, <bpt id="2">&lt;classname&gt;</bpt>UserList<ept id="2">&lt;/classname&gt;</ept>, and <ph id="3">&amp;userdict_classname;</ph>. Using a combination of normal and special methods, the <ph id="4">&amp;userdict_classname;</ph> class does an excellent imitation of a dictionary.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517006</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="238" reformat="yes" translate="yes" xml:space="default">
        <source>In <ph id="1">&amp;python;</ph> 2.2 and later, you can inherit classes directly from built-in datatypes like <ph id="2">&amp;dict;</ph>. An example of this is given in the examples that come with this book, in <bpt id="3">&lt;filename&gt;</bpt>fileinfo_fromdict.py<ept id="3">&lt;/filename&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517007</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="239" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="close">&lt;/note&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517008</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="240" reformat="yes" translate="yes" xml:space="default">
        <source>In <ph id="1">&amp;python;</ph>, you can inherit directly from the <ph id="2">&amp;dict;</ph> built-in datatype, as shown in this example.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517009</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="241" reformat="yes" translate="yes" xml:space="default">
        <source>There are three differences here compared to the <ph id="1">&amp;userdict;</ph> version.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517010</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="242" reformat="yes" translate="yes" xml:space="default">
        <source>Inheriting Directly from Built-In Datatype <ph id="1">&amp;dict;</ph>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517011</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="243" reformat="yes" translate="yes" xml:space="default">
        <source>The first difference is that you don't need to import the <ph id="1">&amp;userdict;</ph> module, since <ph id="2">&amp;dict;</ph> is a built-in datatype and is always available.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517012</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="244" reformat="yes" translate="yes" xml:space="default">
        <source>The second is that you are inheriting from <ph id="1">&amp;dict;</ph> directly, instead of from <bpt id="2">&lt;function&gt;</bpt>UserDict.UserDict<ept id="2">&lt;/function&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517013</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="245" reformat="yes" translate="yes" xml:space="default">
        <source>The third difference is subtle but important.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517014</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="246" reformat="yes" translate="yes" xml:space="default">
        <source>Because of the way <ph id="1">&amp;userdict;</ph> works internally, it requires you to manually call its <ph id="2">&amp;init;</ph> method to properly initialize its internal data structures.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517015</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="247" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;dict;</ph> does not work like this; it is not a wrapper, and it requires no explicit initialization.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517018</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="248" reformat="yes" translate="yes" xml:space="default">
        <source>Further Reading on <ph id="1">&amp;userdict;</ph>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517019</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="249" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;pythonlibraryreference;</ph> documents the <bpt id="2">&lt;ulink url=&quot;&amp;url_pythonlibraryreference;module-UserDict.html&quot;&gt;</bpt>
          <ph id="3">&amp;userdict;</ph> module<ept id="2">&lt;/ulink&gt;</ept> and the <bpt id="4">&lt;ulink url=&quot;&amp;url_pythonlibraryreference;module-copy.html&quot;&gt;</bpt>
          <ph id="5">&amp;copy;</ph> module<ept id="4">&lt;/ulink&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517020</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="250" reformat="yes" translate="yes" xml:space="default">
        <source>Special Class Methods</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517021</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="251" reformat="yes" translate="yes" xml:space="default">
        <source>In addition to normal class methods, there are a number of special methods that <ph id="1">&amp;python;</ph> classes can define.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517022</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="252" reformat="yes" translate="yes" xml:space="default">
        <source>Instead of being called directly by your code (like normal methods), special methods are called for you by <ph id="1">&amp;python;</ph> in particular circumstances or when specific syntax is used.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517023</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="253" reformat="yes" translate="yes" xml:space="default">
        <source>As you saw in the <bpt id="1">&lt;link linkend=&quot;fileinfo.userdict&quot;&gt;</bpt>previous section<ept id="1">&lt;/link&gt;</ept>, normal methods go a long way towards wrapping a dictionary in a class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517024</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="254" reformat="yes" translate="yes" xml:space="default">
        <source>But normal methods alone are not enough, because there are a lot of things you can do with dictionaries besides call methods on them.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517025</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="255" reformat="yes" translate="yes" xml:space="default">
        <source>For starters, you can <bpt id="1">&lt;link linkend=&quot;odbchelper.dict.define&quot;&gt;</bpt>get<ept id="1">&lt;/link&gt;</ept> and <bpt id="2">&lt;link linkend=&quot;odbchelper.dict.modify&quot;&gt;</bpt>set<ept id="2">&lt;/link&gt;</ept> items with a syntax that doesn't include explicitly invoking methods.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517028</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="256" reformat="yes" translate="yes" xml:space="default">
        <source>This is where special class methods come in:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517029</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="257" reformat="yes" translate="yes" xml:space="default">
        <source>they provide a way to map non-method-calling syntax into method calls.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517030</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="258" reformat="yes" translate="yes" xml:space="default">
        <source>Getting and Setting Items</source>
        <target state="needs-review-adaptation" state-qualifier="exact-match" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517031</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="259" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;getitem;</ph> Special Method</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517032</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="260" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;getitem;</ph> special method looks simple enough.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517033</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="261" reformat="yes" translate="yes" xml:space="default">
        <source>Like the normal methods <ph id="1">&amp;clear;</ph>, <ph id="2">&amp;keys;</ph>, and <ph id="3">&amp;values;</ph>, it just redirects to the dictionary to return its value.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517034</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="262" reformat="yes" translate="yes" xml:space="default">
        <source>But how does it get called?</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517035</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="263" reformat="yes" translate="yes" xml:space="default">
        <source>Well, you can call <ph id="1">&amp;getitem;</ph> directly, but in practice you wouldn't actually do that; I'm just doing it here to show you how it works.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517036</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="264" reformat="yes" translate="yes" xml:space="default">
        <source>The right way to use <ph id="1">&amp;getitem;</ph> is to get <ph id="2">&amp;python;</ph> to call it for you.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517037</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="265" reformat="yes" translate="yes" xml:space="default">
        <source>This looks just like the syntax you would use to <bpt id="1">&lt;link linkend=&quot;odbchelper.dict.define&quot;&gt;</bpt>get a dictionary value<ept id="1">&lt;/link&gt;</ept>, and in fact it returns the value you would expect.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517038</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="266" reformat="yes" translate="yes" xml:space="default">
        <source>But here's the missing link:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517039</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="267" reformat="yes" translate="yes" xml:space="default">
        <source>under the covers, <ph id="1">&amp;python;</ph> has converted this syntax to the method call <bpt id="2">&lt;literal&gt;</bpt>f.__getitem__(&quot;name&quot;)<ept id="2">&lt;/literal&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517040</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="268" reformat="yes" translate="yes" xml:space="default">
        <source>That's why <ph id="1">&amp;getitem;</ph> is a special class method; not only can you call it yourself, you can get <ph id="2">&amp;python;</ph> to call it for you by using the right syntax.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517041</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="269" reformat="yes" translate="yes" xml:space="default">
        <source>Of course, <ph id="1">&amp;python;</ph> has a <ph id="2">&amp;setitem;</ph> special method to go along with <ph id="3">&amp;getitem;</ph>, as shown in the next example.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517042</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="270" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;setitem;</ph> Special Method</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517043</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="271" reformat="yes" translate="yes" xml:space="default">
        <source>Like the <ph id="1">&amp;getitem;</ph> method, <ph id="2">&amp;setitem;</ph> simply redirects to the real dictionary <bpt id="3">&lt;varname&gt;</bpt>self.data<ept id="3">&lt;/varname&gt;</ept> to do its work.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517044</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="272" reformat="yes" translate="yes" xml:space="default">
        <source>And like <ph id="1">&amp;getitem;</ph>, you wouldn't ordinarily call it directly like this; <ph id="2">&amp;python;</ph> calls <ph id="3">&amp;setitem;</ph> for you when you use the right syntax.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517045</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="273" reformat="yes" translate="yes" xml:space="default">
        <source>This looks like regular dictionary syntax, except of course that <bpt id="1">&lt;varname&gt;</bpt>f<ept id="1">&lt;/varname&gt;</ept> is really a class that's trying very hard to masquerade as a dictionary, and <ph id="2">&amp;setitem;</ph> is an essential part of that masquerade.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517046</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="274" reformat="yes" translate="yes" xml:space="default">
        <source>This line of code actually calls <bpt id="1">&lt;literal&gt;</bpt>f.__setitem__(&quot;genre&quot;, 32)<ept id="1">&lt;/literal&gt;</ept> under the covers.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517047</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="275" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;setitem;</ph> is a special class method because it gets called for you, but it's still a class method.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517048</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="276" reformat="yes" translate="yes" xml:space="default">
        <source>Just as easily as the <ph id="1">&amp;setitem;</ph> method was defined in <ph id="2">&amp;userdict_classname;</ph>, you can redefine it in the descendant class to override the ancestor method.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517049</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="277" reformat="yes" translate="yes" xml:space="default">
        <source>This allows you to define classes that act like dictionaries in some ways but define their own behavior above and beyond the built-in dictionary.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517050</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="278" reformat="yes" translate="yes" xml:space="default">
        <source>This concept is the basis of the entire framework you're studying in this chapter.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517051</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="279" reformat="yes" translate="yes" xml:space="default">
        <source>Each file type can have a handler class that knows how to get metadata from a particular type of file.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517052</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="280" reformat="yes" translate="yes" xml:space="default">
        <source>Once some attributes (like the file's name and location) are known, the handler class knows how to derive other attributes automatically.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517053</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="281" reformat="yes" translate="yes" xml:space="default">
        <source>This is done by overriding the <ph id="1">&amp;setitem;</ph> method, checking for particular keys, and adding additional processing when they are found.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517054</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="282" reformat="yes" translate="yes" xml:space="default">
        <source>For example, <ph id="1">&amp;mp3fileinfo_classname;</ph> is a descendant of <ph id="2">&amp;fileinfo_classname;</ph>. When an <ph id="3">&amp;mp3fileinfo_classname;</ph>'s <bpt id="4">&lt;literal&gt;</bpt>name<ept id="4">&lt;/literal&gt;</ept> is set, it doesn't just set the <bpt id="5">&lt;literal&gt;</bpt>name<ept id="5">&lt;/literal&gt;</ept> key (like the ancestor <ph id="6">&amp;fileinfo_classname;</ph> does); it also looks in the file itself for <ph id="7">&amp;mp3;</ph> tags and populates a whole set of keys.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517055</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="283" reformat="yes" translate="yes" xml:space="default">
        <source>The next example shows how this works.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517056</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="284" reformat="yes" translate="yes" xml:space="default">
        <source>Overriding <ph id="1">&amp;setitem;</ph> in <ph id="2">&amp;mp3fileinfo_classname;</ph>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517057</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="285" reformat="yes" translate="yes" xml:space="default">
        <source>Notice that this <ph id="1">&amp;setitem;</ph> method is defined exactly the same way as the ancestor method.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517058</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="286" reformat="yes" translate="yes" xml:space="default">
        <source>This is important, since <ph id="1">&amp;python;</ph> will be calling the method for you, and it expects it to be defined with a certain number of arguments.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517059</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="287" reformat="yes" translate="yes" xml:space="default">
        <source>(Technically speaking, the names of the arguments don't matter; only the number of arguments is important.)</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517060</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="288" reformat="yes" translate="yes" xml:space="default">
        <source>Here's the crux of the entire <ph id="1">&amp;mp3fileinfo_classname;</ph> class:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517061</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="289" reformat="yes" translate="yes" xml:space="default">
        <source>if you're assigning a value to the <bpt id="1">&lt;literal&gt;</bpt>name<ept id="1">&lt;/literal&gt;</ept> key, you want to do something extra.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517062</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="290" reformat="yes" translate="yes" xml:space="default">
        <source>The extra processing you do for <bpt id="1">&lt;literal&gt;</bpt>name<ept id="1">&lt;/literal&gt;</ept>s is encapsulated in the <ph id="2">&amp;fileinfo_parse;</ph> method.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517063</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="291" reformat="yes" translate="yes" xml:space="default">
        <source>This is another class method defined in <ph id="1">&amp;mp3fileinfo_classname;</ph>, and when you call it, you qualify it with <bpt id="2">&lt;varname&gt;</bpt>self<ept id="2">&lt;/varname&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517064</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="292" reformat="yes" translate="yes" xml:space="default">
        <source>Just calling <bpt id="1">&lt;function&gt;</bpt>__parse<ept id="1">&lt;/function&gt;</ept> would look for a normal function defined outside the class, which is not what you want.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517065</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="293" reformat="yes" translate="yes" xml:space="default">
        <source>Calling <bpt id="1">&lt;function&gt;</bpt>self.__parse<ept id="1">&lt;/function&gt;</ept> will look for a class method defined within the class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517066</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="294" reformat="yes" translate="yes" xml:space="default">
        <source>This isn't anything new; you reference <bpt id="1">&lt;link linkend=&quot;fileinfo.userdict.normalmethods&quot;&gt;</bpt>data attributes<ept id="1">&lt;/link&gt;</ept> the same way.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517067</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="295" reformat="yes" translate="yes" xml:space="default">
        <source>After doing this extra processing, you want to call the ancestor method.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517068</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="296" reformat="yes" translate="yes" xml:space="default">
        <source>Remember that this is never done for you in <ph id="1">&amp;python;</ph>; you must do it manually.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517069</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="297" reformat="yes" translate="yes" xml:space="default">
        <source>Note that you're calling the immediate ancestor, <ph id="1">&amp;fileinfo_classname;</ph>, even though it doesn't have a <ph id="2">&amp;setitem;</ph> method.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517070</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="298" reformat="yes" translate="yes" xml:space="default">
        <source>That's okay, because <ph id="1">&amp;python;</ph> will walk up the ancestor tree until it finds a class with the method you're calling, so this line of code will eventually find and call the <ph id="2">&amp;setitem;</ph> defined in <ph id="3">&amp;userdict_classname;</ph>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517071</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="299" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="open">&lt;note id=&quot;tip.self.call&quot;&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517072</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="300" reformat="yes" translate="yes" xml:space="default">
        <source>When accessing data attributes within a class, you need to qualify the attribute name:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517073</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="301" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;literal&gt;</bpt>self.<bpt id="2">&lt;replaceable&gt;</bpt>attribute<ept id="2">&lt;/replaceable&gt;</ept>
          <ept id="1">&lt;/literal&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517074</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="302" reformat="yes" translate="yes" xml:space="default">
        <source>When calling other methods within a class, you need to qualify the method name:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517075</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="303" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;literal&gt;</bpt>self.<bpt id="2">&lt;replaceable&gt;</bpt>method<ept id="2">&lt;/replaceable&gt;</ept>
          <ept id="1">&lt;/literal&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517076</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="304" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="close">&lt;/note&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517077</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="305" reformat="yes" translate="yes" xml:space="default">
        <source>Setting an <ph id="1">&amp;mp3fileinfo_classname;</ph>'s <bpt id="2">&lt;literal&gt;</bpt>name<ept id="2">&lt;/literal&gt;</ept>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517078</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="306" reformat="yes" translate="yes" xml:space="default">
        <source>First, you create an instance of <ph id="1">&amp;mp3fileinfo_classname;</ph>, without passing it a filename.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517079</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="307" reformat="yes" translate="yes" xml:space="default">
        <source>(You can get away with this because the <bpt id="1">&lt;varname&gt;</bpt>filename<ept id="1">&lt;/varname&gt;</ept> argument of the <ph id="2">&amp;init;</ph> method is <bpt id="3">&lt;link linkend=&quot;apihelper.optional&quot;&gt;</bpt>optional<ept id="3">&lt;/link&gt;</ept>.) Since <ph id="4">&amp;mp3fileinfo_classname;</ph> has no <ph id="5">&amp;init;</ph> method of its own, <ph id="6">&amp;python;</ph> walks up the ancestor tree and finds the <ph id="7">&amp;init;</ph> method of <ph id="8">&amp;fileinfo_classname;</ph>. This <ph id="9">&amp;init;</ph> method manually calls the <ph id="10">&amp;init;</ph> method of <ph id="11">&amp;userdict_classname;</ph> and then sets the <bpt id="12">&lt;literal&gt;</bpt>name<ept id="12">&lt;/literal&gt;</ept> key to <bpt id="13">&lt;varname&gt;</bpt>filename<ept id="13">&lt;/varname&gt;</ept>, which is <ph id="14">&amp;none;</ph>, since you didn't pass a filename.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517080</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="308" reformat="yes" translate="yes" xml:space="default">
        <source>Thus, <bpt id="1">&lt;varname&gt;</bpt>mp3file<ept id="1">&lt;/varname&gt;</ept> initially looks like a dictionary with one key, <bpt id="2">&lt;literal&gt;</bpt>name<ept id="2">&lt;/literal&gt;</ept>, whose value is <ph id="3">&amp;none;</ph>. </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517081</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="309" reformat="yes" translate="yes" xml:space="default">
        <source>Now the real fun begins.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517084</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="310" reformat="yes" translate="yes" xml:space="default">
        <source>Setting the <bpt id="1">&lt;literal&gt;</bpt>name<ept id="1">&lt;/literal&gt;</ept> key of <bpt id="2">&lt;varname&gt;</bpt>mp3file<ept id="2">&lt;/varname&gt;</ept> triggers the <ph id="3">&amp;setitem;</ph> method on <ph id="4">&amp;mp3fileinfo_classname;</ph> (not <ph id="5">&amp;userdict_classname;</ph>), which notices that you're setting the <bpt id="6">&lt;literal&gt;</bpt>name<ept id="6">&lt;/literal&gt;</ept> key with a real value and calls <bpt id="7">&lt;function&gt;</bpt>self.__parse<ept id="7">&lt;/function&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517085</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="311" reformat="yes" translate="yes" xml:space="default">
        <source>Although you haven't traced through the <bpt id="1">&lt;function&gt;</bpt>__parse<ept id="1">&lt;/function&gt;</ept> method yet, you can see from the output that it sets several other keys:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517086</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="312" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;literal&gt;</bpt>album<ept id="1">&lt;/literal&gt;</ept>, <bpt id="2">&lt;literal&gt;</bpt>artist<ept id="2">&lt;/literal&gt;</ept>, <bpt id="3">&lt;literal&gt;</bpt>genre<ept id="3">&lt;/literal&gt;</ept>, <bpt id="4">&lt;literal&gt;</bpt>title<ept id="4">&lt;/literal&gt;</ept>, <bpt id="5">&lt;literal&gt;</bpt>year<ept id="5">&lt;/literal&gt;</ept>, and <bpt id="6">&lt;literal&gt;</bpt>comment<ept id="6">&lt;/literal&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517087</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="313" reformat="yes" translate="yes" xml:space="default">
        <source>Modifying the <bpt id="1">&lt;literal&gt;</bpt>name<ept id="1">&lt;/literal&gt;</ept> key will go through the same process again:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517088</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="314" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph> calls <ph id="2">&amp;setitem;</ph>, which calls <bpt id="3">&lt;function&gt;</bpt>self.__parse<ept id="3">&lt;/function&gt;</ept>, which sets all the other keys.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517090</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="315" reformat="yes" translate="yes" xml:space="default">
        <source>Advanced Special Class Methods</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517091</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="316" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph> has more special methods than just <ph id="2">&amp;getitem;</ph> and <ph id="3">&amp;setitem;</ph>. Some of them let you emulate functionality that you may not even know about.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517092</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="317" reformat="yes" translate="yes" xml:space="default">
        <source>This example shows some of the other special methods in <ph id="1">&amp;userdict;</ph>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517093</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="318" reformat="yes" translate="yes" xml:space="default">
        <source>More Special Methods in <ph id="1">&amp;userdict_classname;</ph>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517094</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="319" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;reprspecial;</ph> is a special method that is called when you call <bpt id="2">&lt;literal&gt;</bpt>repr(<bpt id="3">&lt;replaceable&gt;</bpt>instance<ept id="3">&lt;/replaceable&gt;</ept>)<ept id="2">&lt;/literal&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517095</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="320" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;repr;</ph> function is a built-in function that returns a string representation of an object.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517096</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="321" reformat="yes" translate="yes" xml:space="default">
        <source>It works on any object, not just class instances.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517097</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="322" reformat="yes" translate="yes" xml:space="default">
        <source>You're already intimately familiar with <ph id="1">&amp;repr;</ph> and you don't even know it.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517098</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="323" reformat="yes" translate="yes" xml:space="default">
        <source>In the interactive window, when you type just a variable name and press the <bpt id="1">&lt;keycap&gt;</bpt>ENTER<ept id="1">&lt;/keycap&gt;</ept> key, <ph id="2">&amp;python;</ph> uses <ph id="3">&amp;repr;</ph> to display the variable's value.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517101</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="324" reformat="yes" translate="yes" xml:space="default">
        <source>Go create a dictionary <bpt id="1">&lt;varname&gt;</bpt>d<ept id="1">&lt;/varname&gt;</ept> with some data and then <bpt id="2">&lt;literal&gt;</bpt>print repr(d)<ept id="2">&lt;/literal&gt;</ept> to see for yourself.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517102</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="325" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;cmpspecial;</ph> is called when you compare class instances.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517103</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="326" reformat="yes" translate="yes" xml:space="default">
        <source>In general, you can compare any two <ph id="1">&amp;python;</ph> objects, not just class instances, by using <ph id="2">&amp;comparisonequals;</ph>. There are rules that define when built-in datatypes are considered equal; for instance, dictionaries are equal when they have all the same keys and values, and strings are equal when they are the same length and contain the same sequence of characters.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517104</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="327" reformat="yes" translate="yes" xml:space="default">
        <source>For class instances, you can define the <ph id="1">&amp;cmpspecial;</ph> method and code the comparison logic yourself, and then you can use <ph id="2">&amp;comparisonequals;</ph> to compare instances of your class and <ph id="3">&amp;python;</ph> will call your <ph id="4">&amp;cmpspecial;</ph> special method for you.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517105</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="328" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;lenspecial;</ph> is called when you call <bpt id="2">&lt;literal&gt;</bpt>len(<bpt id="3">&lt;replaceable&gt;</bpt>instance<ept id="3">&lt;/replaceable&gt;</ept>)<ept id="2">&lt;/literal&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517106</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="329" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;len;</ph> function is a built-in function that returns the length of an object.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517107</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="330" reformat="yes" translate="yes" xml:space="default">
        <source>It works on any object that could reasonably be thought of as having a length.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517108</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="331" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;len;</ph> of a string is its number of characters; the <ph id="2">&amp;len;</ph> of a dictionary is its number of keys; the <ph id="3">&amp;len;</ph> of a list or tuple is its number of elements.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517109</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="332" reformat="yes" translate="yes" xml:space="default">
        <source>For class instances, define the <ph id="1">&amp;lenspecial;</ph> method and code the length calculation yourself, and then call <bpt id="2">&lt;literal&gt;</bpt>len(<bpt id="3">&lt;replaceable&gt;</bpt>instance<ept id="3">&lt;/replaceable&gt;</ept>)<ept id="2">&lt;/literal&gt;</ept> and <ph id="4">&amp;python;</ph> will call your <ph id="5">&amp;lenspecial;</ph> special method for you.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517110</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="333" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;delitem;</ph> is called when you call <bpt id="2">&lt;literal&gt;</bpt>del <bpt id="3">&lt;replaceable&gt;</bpt>instance<ept id="3">&lt;/replaceable&gt;</ept>[<bpt id="4">&lt;replaceable&gt;</bpt>key<ept id="4">&lt;/replaceable&gt;</ept>]<ept id="2">&lt;/literal&gt;</ept>, which you may remember as the way to <bpt id="5">&lt;link linkend=&quot;odbchelper.dict.del&quot;&gt;</bpt>delete individual items from a dictionary<ept id="5">&lt;/link&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517111</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="334" reformat="yes" translate="yes" xml:space="default">
        <source>When you use <ph id="1">&amp;del;</ph> on a class instance, <ph id="2">&amp;python;</ph> calls the <ph id="3">&amp;delitem;</ph> special method for you.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517112</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="335" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="open">&lt;note id=&quot;compare.strequals.java&quot; role=&quot;compare&quot; vendor=&quot;java&quot;&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517113</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="336" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph>
          <ph id="2">&amp;vs;</ph>
          <ph id="3">&amp;java;</ph> equality and identity</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517114</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="337" reformat="yes" translate="yes" xml:space="default">
        <source>In <ph id="1">&amp;java;</ph>, you determine whether two string variables reference the same physical memory location by using <bpt id="2">&lt;literal&gt;</bpt>str1 == str2<ept id="2">&lt;/literal&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517115</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="338" reformat="yes" translate="yes" xml:space="default">
        <source>This is called <bpt id="1">&lt;emphasis&gt;</bpt>object identity<ept id="1">&lt;/emphasis&gt;</ept>, and it is written in <ph id="2">&amp;python;</ph> as <bpt id="3">&lt;literal&gt;</bpt>str1 is str2<ept id="3">&lt;/literal&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517116</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="339" reformat="yes" translate="yes" xml:space="default">
        <source>To compare string values in <ph id="1">&amp;java;</ph>, you would use <bpt id="2">&lt;literal&gt;</bpt>str1.equals(str2)<ept id="2">&lt;/literal&gt;</ept>; in <ph id="3">&amp;python;</ph>, you would use <bpt id="4">&lt;literal&gt;</bpt>str1 == str2<ept id="4">&lt;/literal&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517117</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="340" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;java;</ph> programmers who have been taught to believe that the world is a better place because <ph id="2">&amp;comparisonequals;</ph> in <ph id="3">&amp;java;</ph> compares by identity instead of by value may have a difficult time adjusting to <ph id="4">&amp;python;</ph>'s lack of such <bpt id="5">&lt;quote&gt;</bpt>gotchas<ept id="5">&lt;/quote&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517118</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="341" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="close">&lt;/note&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517119</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="342" reformat="yes" translate="yes" xml:space="default">
        <source>At this point, you may be thinking, <bpt id="1">&lt;quote&gt;</bpt>All this work just to do something in a class that I can do with a built-in datatype.<ept id="1">&lt;/quote&gt;</ept>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517120</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="343" reformat="yes" translate="yes" xml:space="default">
        <source>And it's true that life would be easier (and the entire <ph id="1">&amp;userdict_classname;</ph> class would be unnecessary) if you could inherit from built-in datatypes like a dictionary.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517121</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="344" reformat="yes" translate="yes" xml:space="default">
        <source>But even if you could, special methods would still be useful, because they can be used in any class, not just wrapper classes like <ph id="1">&amp;userdict_classname;</ph>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517122</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="345" reformat="yes" translate="yes" xml:space="default">
        <source>Special methods mean that <bpt id="1">&lt;emphasis&gt;</bpt>any class<ept id="1">&lt;/emphasis&gt;</ept> can store key/value pairs like a dictionary, just by defining the <ph id="2">&amp;setitem;</ph> method.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517123</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="346" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;emphasis&gt;</bpt>Any class<ept id="1">&lt;/emphasis&gt;</ept> can act like a sequence, just by defining the <ph id="2">&amp;getitem;</ph> method.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517124</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="347" reformat="yes" translate="yes" xml:space="default">
        <source>Any class that defines the <ph id="1">&amp;cmpspecial;</ph> method can be compared with <ph id="2">&amp;comparisonequals;</ph>. And if your class represents something that has a length, don't define a <bpt id="3">&lt;function&gt;</bpt>GetLength<ept id="3">&lt;/function&gt;</ept> method; define the <ph id="4">&amp;lenspecial;</ph> method and use <bpt id="5">&lt;literal&gt;</bpt>len(<bpt id="6">&lt;replaceable&gt;</bpt>instance<ept id="6">&lt;/replaceable&gt;</ept>)<ept id="5">&lt;/literal&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517125</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="348" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="open">&lt;note id=&quot;note.physical.v.logical&quot;&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517126</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="349" reformat="yes" translate="yes" xml:space="default">
        <source>While other object-oriented languages only let you define the physical model of an object (<bpt id="1">&lt;quote&gt;</bpt>this object has a <bpt id="2">&lt;function&gt;</bpt>GetLength<ept id="2">&lt;/function&gt;</ept> method<ept id="1">&lt;/quote&gt;</ept>), <ph id="3">&amp;python;</ph>'s special class methods like <ph id="4">&amp;lenspecial;</ph> allow you to define the logical model of an object (<bpt id="5">&lt;quote&gt;</bpt>this object has a length<ept id="5">&lt;/quote&gt;</ept>).</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517127</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="350" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="close">&lt;/note&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517128</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="351" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph> has a lot of other special methods.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517129</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="352" reformat="yes" translate="yes" xml:space="default">
        <source>There's a whole set of them that let classes act like numbers, allowing you to add, subtract, and do other arithmetic operations on class instances.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517130</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="353" reformat="yes" translate="yes" xml:space="default">
        <source>(The canonical example of this is a class that represents complex numbers, numbers with both real and imaginary components.) The <ph id="1">&amp;callspecial;</ph> method lets a class act like a function, allowing you to call a class instance directly.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517131</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="354" reformat="yes" translate="yes" xml:space="default">
        <source>And there are other special methods that allow classes to have read-only and write-only data attributes; you'll talk more about those in later chapters.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517132</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="355" reformat="yes" translate="yes" xml:space="default">
        <source>Further Reading on Special Class Methods</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517133</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="356" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;pythonlanguagereference;</ph> documents <bpt id="2">&lt;ulink url=&quot;&amp;url_pythonlanguagereference;specialnames.html&quot;&gt;</bpt>all the special class methods<ept id="2">&lt;/ulink&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517134</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="357" reformat="yes" translate="yes" xml:space="default">
        <source>Introducing Class Attributes</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517135</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="358" reformat="yes" translate="yes" xml:space="default">
        <source>You already know about <bpt id="1">&lt;link linkend=&quot;fileinfo.userdict.init.example&quot;&gt;</bpt>data attributes<ept id="1">&lt;/link&gt;</ept>, which are variables owned by a specific instance of a class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517136</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="359" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph> also supports class attributes, which are variables owned by the class itself.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517137</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="360" reformat="yes" translate="yes" xml:space="default">
        <source>Introducing Class Attributes</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517138</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="361" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;mp3fileinfo_classname;</ph> is the class itself, not any particular instance of the class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517139</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="362" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;tagdatamap;</ph> is a class attribute:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517140</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="363" reformat="yes" translate="yes" xml:space="default">
        <source>literally, an attribute of the class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517141</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="364" reformat="yes" translate="yes" xml:space="default">
        <source>It is available before creating any instances of the class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517142</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="365" reformat="yes" translate="yes" xml:space="default">
        <source>Class attributes are available both through direct reference to the class and through any instance of the class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517143</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="366" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="open">&lt;note id=&quot;compare.classattr.java&quot; role=&quot;compare&quot; vendor=&quot;java&quot;&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517144</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="367" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph> vs.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517145</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="368" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;java;</ph> attribute definitions</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517146</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="369" reformat="yes" translate="yes" xml:space="default">
        <source>In <ph id="1">&amp;java;</ph>, both static variables (called class attributes in <ph id="2">&amp;python;</ph>) and instance variables (called data attributes in <ph id="3">&amp;python;</ph>) are defined immediately after the class definition (one with the <bpt id="4">&lt;literal&gt;</bpt>static<ept id="4">&lt;/literal&gt;</ept> keyword, one without).</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517147</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="370" reformat="yes" translate="yes" xml:space="default">
        <source>In <ph id="1">&amp;python;</ph>, only class attributes can be defined here; data attributes are defined in the <ph id="2">&amp;init;</ph> method.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517148</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="371" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="close">&lt;/note&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517149</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="372" reformat="yes" translate="yes" xml:space="default">
        <source>Class attributes can be used as class-level constants (which is how you use them in <ph id="1">&amp;mp3fileinfo_classname;</ph>), but they are not really constants.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517151</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="373" reformat="yes" translate="yes" xml:space="default">
        <source>You can also change them.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517152</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="374" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="open">&lt;note&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517153</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="375" reformat="yes" translate="yes" xml:space="default">
        <source>There are no constants in <ph id="1">&amp;python;</ph>. Everything can be changed if you try hard enough.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517154</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="376" reformat="yes" translate="yes" xml:space="default">
        <source>This fits with one of the core principles of <ph id="1">&amp;python;</ph>: bad behavior should be discouraged but not banned.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517155</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="377" reformat="yes" translate="yes" xml:space="default">
        <source>If you really want to change the value of <ph id="1">&amp;none;</ph>, you can do it, but don't come running to me when your code is impossible to debug.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517162</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="378" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="close">&lt;/note&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517164</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="379" reformat="yes" translate="yes" xml:space="default">
        <source>Modifying Class Attributes</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517165</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="380" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;varname&gt;</bpt>count<ept id="1">&lt;/varname&gt;</ept> is a class attribute of the <bpt id="2">&lt;classname&gt;</bpt>counter<ept id="2">&lt;/classname&gt;</ept> class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517166</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="381" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;literal&gt;</bpt>__class__<ept id="1">&lt;/literal&gt;</ept> is a built-in attribute of every class instance (of every class).</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517167</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="382" reformat="yes" translate="yes" xml:space="default">
        <source>It is a reference to the class that <bpt id="1">&lt;varname&gt;</bpt>self<ept id="1">&lt;/varname&gt;</ept> is an instance of (in this case, the <bpt id="2">&lt;classname&gt;</bpt>counter<ept id="2">&lt;/classname&gt;</ept> class).</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517168</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="383" reformat="yes" translate="yes" xml:space="default">
        <source>Because <bpt id="1">&lt;varname&gt;</bpt>count<ept id="1">&lt;/varname&gt;</ept> is a class attribute, it is available through direct reference to the class, before you have created any instances of the class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517169</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="384" reformat="yes" translate="yes" xml:space="default">
        <source>Creating an instance of the class calls the <ph id="1">&amp;init;</ph> method, which increments the class attribute <bpt id="2">&lt;varname&gt;</bpt>count<ept id="2">&lt;/varname&gt;</ept> by <ph id="3">&amp;one;</ph>. This affects the class itself, not just the newly created instance.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517171</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="385" reformat="yes" translate="yes" xml:space="default">
        <source>Creating a second instance will increment the class attribute <bpt id="1">&lt;varname&gt;</bpt>count<ept id="1">&lt;/varname&gt;</ept> again.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517172</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="386" reformat="yes" translate="yes" xml:space="default">
        <source>Notice how the class attribute is shared by the class and all instances of the class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517173</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="387" reformat="yes" translate="yes" xml:space="default">
        <source>Private Functions</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517174</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="388" reformat="yes" translate="yes" xml:space="default">
        <source>Like most languages, <ph id="1">&amp;python;</ph> has the concept of private elements:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517175</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="389" reformat="yes" translate="yes" xml:space="default">
        <source>Private functions, which can't be called from outside their module</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517176</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="390" reformat="yes" translate="yes" xml:space="default">
        <source>Private class methods, which can't be called from outside their class</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517177</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="391" reformat="yes" translate="yes" xml:space="default">
        <source>Private attributes, which can't be accessed from outside their class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517178</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="392" reformat="yes" translate="yes" xml:space="default">
        <source>Unlike in most languages, whether a <ph id="1">&amp;python;</ph> function, method, or attribute is private or public is determined entirely by its name.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517181</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="393" reformat="yes" translate="yes" xml:space="default">
        <source>If the name of a <ph id="1">&amp;python;</ph> function, class method, or attribute starts with (but doesn't end with) two underscores, it's private; everything else is public.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517182</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="394" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph> has no concept of <bpt id="2">&lt;emphasis&gt;</bpt>protected<ept id="2">&lt;/emphasis&gt;</ept> class methods (accessible only in their own class and descendant classes).</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517183</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="395" reformat="yes" translate="yes" xml:space="default">
        <source>Class methods are either private (accessible only in their own class) or public (accessible from anywhere).</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517184</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="396" reformat="yes" translate="yes" xml:space="default">
        <source>In <ph id="1">&amp;mp3fileinfo_classname;</ph>, there are two methods:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517185</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="397" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;function&gt;</bpt>__parse<ept id="1">&lt;/function&gt;</ept> and <ph id="2">&amp;setitem;</ph>. As you have already discussed, <ph id="3">&amp;setitem;</ph> is a <bpt id="4">&lt;link linkend=&quot;fileinfo.specialmethods.setitem.example&quot;&gt;</bpt>special method<ept id="4">&lt;/link&gt;</ept>; normally, you would call it indirectly by using the dictionary syntax on a class instance, but it is public, and you could call it directly (even from outside the <ph id="5">&amp;fileinfo_modulename;</ph> module) if you had a really good reason.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517186</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="398" reformat="yes" translate="yes" xml:space="default">
        <source>However, <bpt id="1">&lt;function&gt;</bpt>__parse<ept id="1">&lt;/function&gt;</ept> is private, because it has two underscores at the beginning of its name.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517187</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="399" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="open">&lt;note id=&quot;tip.specialmethodnames&quot;&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517188</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="400" reformat="yes" translate="yes" xml:space="default">
        <source>Method Naming Conventions</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517189</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="401" reformat="yes" translate="yes" xml:space="default">
        <source>In <ph id="1">&amp;python;</ph>, all special methods (like <bpt id="2">&lt;link linkend=&quot;fileinfo.specialmethods.setitem.example&quot;&gt;</bpt>
          <ph id="3">&amp;setitem;</ph>
          <ept id="2">&lt;/link&gt;</ept>) and built-in attributes (like <bpt id="4">&lt;link linkend=&quot;odbchelper.import&quot;&gt;</bpt>
          <ph id="5">&amp;doc;</ph>
          <ept id="4">&lt;/link&gt;</ept>) follow a standard naming convention:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517190</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="402" reformat="yes" translate="yes" xml:space="default">
        <source>they both start with and end with two underscores.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517191</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="403" reformat="yes" translate="yes" xml:space="default">
        <source>Don't name your own methods and attributes this way, because it will only confuse you (and others) later.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517192</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="404" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="close">&lt;/note&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517193</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="405" reformat="yes" translate="yes" xml:space="default">
        <source>Trying to Call a Private Method</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517194</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="406" reformat="yes" translate="yes" xml:space="default">
        <source>If you try to call a private method, <ph id="1">&amp;python;</ph> will raise a slightly misleading exception, saying that the method does not exist.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517195</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="407" reformat="yes" translate="yes" xml:space="default">
        <source>Of course it does exist, but it's private, so it's not accessible outside the class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517196</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="408" reformat="yes" translate="yes" xml:space="default">
        <source>Strictly speaking, private methods are accessible outside their class, just not <bpt id="1">&lt;emphasis&gt;</bpt>easily<ept id="1">&lt;/emphasis&gt;</ept> accessible.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517197</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="409" reformat="yes" translate="yes" xml:space="default">
        <source>Nothing in <ph id="1">&amp;python;</ph> is truly private; internally, the names of private methods and attributes are mangled and unmangled on the fly to make them seem inaccessible by their given names.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517198</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="410" reformat="yes" translate="yes" xml:space="default">
        <source>You can access the <bpt id="1">&lt;function&gt;</bpt>__parse<ept id="1">&lt;/function&gt;</ept> method of the <ph id="2">&amp;mp3fileinfo_classname;</ph> class by the name <bpt id="3">&lt;function&gt;</bpt>_MP3FileInfo__parse<ept id="3">&lt;/function&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517199</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="411" reformat="yes" translate="yes" xml:space="default">
        <source>Acknowledge that this is interesting, but promise to never, ever do it in real code.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517200</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="412" reformat="yes" translate="yes" xml:space="default">
        <source>Private methods are private for a reason, but like many other things in <ph id="1">&amp;python;</ph>, their privateness is ultimately a matter of convention, not force.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517201</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="413" reformat="yes" translate="yes" xml:space="default">
        <source>Further Reading on Private Functions</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517202</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="414" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;pythontutorial;</ph> discusses the inner workings of <bpt id="2">&lt;ulink url=&quot;&amp;url_pythontutorial;node11.html#SECTION0011600000000000000000&quot;&gt;</bpt>private variables<ept id="2">&lt;/ulink&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517203</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="415" reformat="yes" translate="yes" xml:space="default">
        <source>Summary</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517204</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="416" reformat="yes" translate="yes" xml:space="default">
        <source>That's it for the hard-core object trickery.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517205</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="417" reformat="yes" translate="yes" xml:space="default">
        <source>You'll see a real-world application of special class methods in <ph id="1">&lt;xref linkend=&quot;soap&quot; endterm=&quot;soap.numberonly&quot;/&gt;</ph>, which uses <ph id="2">&amp;getattr;</ph> to create a proxy to a remote web service.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517206</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="418" reformat="yes" translate="yes" xml:space="default">
        <source>The next chapter will continue using this code sample to explore other <ph id="1">&amp;python;</ph> concepts, such as exceptions, file objects, and <ph id="2">&amp;for;</ph> loops.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517207</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="419" reformat="yes" translate="yes" xml:space="default">
        <source>Before diving into the next chapter, make sure you're comfortable doing all of these things:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517208</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="420" reformat="yes" translate="yes" xml:space="default">
        <source>Importing modules using either <bpt id="1">&lt;link linkend=&quot;odbchelper.import&quot;&gt;</bpt>
          <ph id="2">&amp;importmodule;</ph>
          <ept id="1">&lt;/link&gt;</ept> or <bpt id="3">&lt;link linkend=&quot;fileinfo.fromimport&quot;&gt;</bpt>
          <ph id="4">&amp;frommoduleimport;</ph>
          <ept id="3">&lt;/link&gt;</ept>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517209</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="421" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;link linkend=&quot;fileinfo.class&quot;&gt;</bpt>Defining<ept id="1">&lt;/link&gt;</ept> and <bpt id="2">&lt;link linkend=&quot;fileinfo.create&quot;&gt;</bpt>instantiating<ept id="2">&lt;/link&gt;</ept> classes</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517210</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="422" reformat="yes" translate="yes" xml:space="default">
        <source>Defining <bpt id="1">&lt;link linkend=&quot;fileinfo.class.example&quot;&gt;</bpt>
          <ph id="2">&amp;init;</ph> methods<ept id="1">&lt;/link&gt;</ept> and other <bpt id="3">&lt;link linkend=&quot;fileinfo.specialmethods&quot;&gt;</bpt>special class methods<ept id="3">&lt;/link&gt;</ept>, and understanding when they are called</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517211</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="423" reformat="yes" translate="yes" xml:space="default">
        <source>Subclassing <bpt id="1">&lt;link linkend=&quot;fileinfo.userdict&quot;&gt;</bpt>
          <ph id="2">&amp;userdict_classname;</ph>
          <ept id="1">&lt;/link&gt;</ept> to define classes that act like dictionaries</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517212</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="424" reformat="yes" translate="yes" xml:space="default">
        <source>Defining <bpt id="1">&lt;link linkend=&quot;fileinfo.userdict.init.example&quot;&gt;</bpt>data attributes<ept id="1">&lt;/link&gt;</ept> and <bpt id="2">&lt;link linkend=&quot;fileinfo.classattributes&quot;&gt;</bpt>class attributes<ept id="2">&lt;/link&gt;</ept>, and understanding the differences between them</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517213</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="425" reformat="yes" translate="yes" xml:space="default">
        <source>Defining <bpt id="1">&lt;link linkend=&quot;fileinfo.private&quot;&gt;</bpt>private attributes and methods<ept id="1">&lt;/link&gt;</ept>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517214</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="426" reformat="yes" translate="yes" xml:space="default">
        <source>Exceptions and File Handling</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517215</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="427" reformat="yes" translate="yes" xml:space="default">
        <source>Chapter 6</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517216</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="428" reformat="yes" translate="yes" xml:space="default">
        <source>In this chapter, you will dive into exceptions, file objects, <ph id="1">&amp;for;</ph> loops, and the <ph id="2">&amp;os;</ph> and <ph id="3">&amp;sys;</ph> modules.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517217</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="429" reformat="yes" translate="yes" xml:space="default">
        <source>If you've used exceptions in another programming language, you can skim the first section to get a sense of <ph id="1">&amp;python;</ph>'s syntax.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517218</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="430" reformat="yes" translate="yes" xml:space="default">
        <source>Be sure to tune in again for file handling.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517219</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="431" reformat="yes" translate="yes" xml:space="default">
        <source>Handling Exceptions</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517220</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="432" reformat="yes" translate="yes" xml:space="default">
        <source>Like many other programming languages, <ph id="1">&amp;python;</ph> has exception handling via <ph id="2">&amp;tryexcept;</ph> blocks.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517221</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="433" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="open">&lt;note id=&quot;compare.exceptions.java&quot; role=&quot;compare&quot; vendor=&quot;java&quot;&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517222</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="434" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph>
          <ph id="2">&amp;vs;</ph>
          <ph id="3">&amp;java;</ph> exception handling</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517223</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="435" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph> uses <ph id="2">&amp;tryexcept;</ph> to handle exceptions and <bpt id="3">&lt;literal&gt;</bpt>raise<ept id="3">&lt;/literal&gt;</ept> to generate them.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517224</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="436" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;java;</ph> and <ph id="2">&amp;cpp;</ph> use <bpt id="3">&lt;literal&gt;</bpt>try...catch<ept id="3">&lt;/literal&gt;</ept> to handle exceptions, and <bpt id="4">&lt;literal&gt;</bpt>throw<ept id="4">&lt;/literal&gt;</ept> to generate them.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517225</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="437" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="close">&lt;/note&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517226</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="438" reformat="yes" translate="yes" xml:space="default">
        <source>Exceptions are everywhere in <ph id="1">&amp;python;</ph>. Virtually every module in the standard <ph id="2">&amp;python;</ph> library uses them, and <ph id="3">&amp;python;</ph> itself will raise them in a lot of different circumstances.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517227</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="439" reformat="yes" translate="yes" xml:space="default">
        <source>You've already seen them repeatedly throughout this book.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517228</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="440" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;link linkend=&quot;odbchelper.dict.define&quot;&gt;</bpt>Accessing a non-existent dictionary key<ept id="1">&lt;/link&gt;</ept> will raise a <bpt id="2">&lt;errorcode&gt;</bpt>KeyError<ept id="2">&lt;/errorcode&gt;</ept> exception.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517229</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="441" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;link linkend=&quot;odbchelper.list.search&quot;&gt;</bpt>Searching a list for a non-existent value<ept id="1">&lt;/link&gt;</ept> will raise a <bpt id="2">&lt;errorcode&gt;</bpt>ValueError<ept id="2">&lt;/errorcode&gt;</ept> exception.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517230</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="442" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;link linkend=&quot;odbchelper.tuplemethods&quot;&gt;</bpt>Calling a non-existent method<ept id="1">&lt;/link&gt;</ept> will raise an <bpt id="2">&lt;errorcode&gt;</bpt>AttributeError<ept id="2">&lt;/errorcode&gt;</ept> exception.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517231</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="443" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;link linkend=&quot;odbchelper.unboundvariable&quot;&gt;</bpt>Referencing a non-existent variable<ept id="1">&lt;/link&gt;</ept> will raise a <bpt id="2">&lt;errorcode&gt;</bpt>NameError<ept id="2">&lt;/errorcode&gt;</ept> exception.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517232</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="444" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;link linkend=&quot;odbchelper.stringformatting.coerce&quot;&gt;</bpt>Mixing datatypes without coercion<ept id="1">&lt;/link&gt;</ept> will raise a <bpt id="2">&lt;errorcode&gt;</bpt>TypeError<ept id="2">&lt;/errorcode&gt;</ept> exception.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517233</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="445" reformat="yes" translate="yes" xml:space="default">
        <source>In each of these cases, you were simply playing around in the <ph id="1">&amp;python;</ph>
          <ph id="2">&amp;ide;</ph>: an error occurred, the exception was printed (depending on your <ph id="3">&amp;ide;</ph>, perhaps in an intentionally jarring shade of red), and that was that.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517234</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="446" reformat="yes" translate="yes" xml:space="default">
        <source>This is called an <bpt id="1">&lt;emphasis&gt;</bpt>unhandled<ept id="1">&lt;/emphasis&gt;</ept> exception.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517235</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="447" reformat="yes" translate="yes" xml:space="default">
        <source>When the exception was raised, there was no code to explicitly notice it and deal with it, so it bubbled its way back to the default behavior built in to <ph id="1">&amp;python;</ph>, which is to spit out some debugging information and give up.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517236</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="448" reformat="yes" translate="yes" xml:space="default">
        <source>In the <ph id="1">&amp;ide;</ph>, that's no big deal, but if that happened while your actual <ph id="2">&amp;python;</ph> program was running, the entire program would come to a screeching halt.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517237</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="449" reformat="yes" translate="yes" xml:space="default">
        <source>An exception doesn't need result in a complete program crash, though.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517238</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="450" reformat="yes" translate="yes" xml:space="default">
        <source>Exceptions, when raised, can be <bpt id="1">&lt;emphasis&gt;</bpt>handled<ept id="1">&lt;/emphasis&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517239</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="451" reformat="yes" translate="yes" xml:space="default">
        <source>Sometimes an exception is really because you have a bug in your code (like accessing a variable that doesn't exist), but many times, an exception is something you can anticipate.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517240</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="452" reformat="yes" translate="yes" xml:space="default">
        <source>If you're opening a file, it might not exist.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517241</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="453" reformat="yes" translate="yes" xml:space="default">
        <source>If you're connecting to a database, it might be unavailable, or you might not have the correct security credentials to access it.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517242</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="454" reformat="yes" translate="yes" xml:space="default">
        <source>If you know a line of code may raise an exception, you should handle the exception using a <ph id="1">&amp;tryexcept;</ph> block.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517243</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="455" reformat="yes" translate="yes" xml:space="default">
        <source>Opening a Non-Existent File</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517244</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="456" reformat="yes" translate="yes" xml:space="default">
        <source>Using the built-in <ph id="1">&amp;open;</ph> function, you can try to open a file for reading (more on <ph id="2">&amp;open;</ph> in the next section).</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517246</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="457" reformat="yes" translate="yes" xml:space="default">
        <source>But the file doesn't exist, so this raises the <ph id="1">&amp;ioerror;</ph> exception.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517247</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="458" reformat="yes" translate="yes" xml:space="default">
        <source>Since you haven't provided any explicit check for an <ph id="1">&amp;ioerror;</ph> exception, <ph id="2">&amp;python;</ph> just prints out some debugging information about what happened and then gives up.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517248</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="459" reformat="yes" translate="yes" xml:space="default">
        <source>You're trying to open the same non-existent file, but this time you're doing it within a <ph id="1">&amp;tryexcept;</ph> block.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517249</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="460" reformat="yes" translate="yes" xml:space="default">
        <source>When the <ph id="1">&amp;open;</ph> method raises an <ph id="2">&amp;ioerror;</ph> exception, you're ready for it.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517250</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="461" reformat="yes" translate="yes" xml:space="default">
        <source>The <bpt id="1">&lt;literal&gt;</bpt>except IOError:<ept id="1">&lt;/literal&gt;</ept>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517251</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="462" reformat="yes" translate="yes" xml:space="default">
        <source>line catches the exception and executes your own block of code, which in this case just prints a more pleasant error message.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517252</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="463" reformat="yes" translate="yes" xml:space="default">
        <source>Once an exception has been handled, processing continues normally on the first line after the <ph id="1">&amp;tryexcept;</ph> block.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517253</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="464" reformat="yes" translate="yes" xml:space="default">
        <source>Note that this line will always print, whether or not an exception occurs.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517254</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="465" reformat="yes" translate="yes" xml:space="default">
        <source>If you really did have a file called <bpt id="1">&lt;filename&gt;</bpt>notthere<ept id="1">&lt;/filename&gt;</ept> in your root directory, the call to <ph id="2">&amp;open;</ph> would succeed, the <bpt id="3">&lt;literal&gt;</bpt>except<ept id="3">&lt;/literal&gt;</ept> clause would be ignored, and this line would still be executed.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517255</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="466" reformat="yes" translate="yes" xml:space="default">
        <source>Exceptions may seem unfriendly (after all, if you don't catch the exception, your entire program will crash), but consider the alternative.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517256</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="467" reformat="yes" translate="yes" xml:space="default">
        <source>Would you rather get back an unusable file object to a non-existent file?</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517257</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="468" reformat="yes" translate="yes" xml:space="default">
        <source>You'd need to check its validity somehow anyway, and if you forgot, somewhere down the line, your program would give you strange errors somewhere down the line that you would need to trace back to the source.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517258</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="469" reformat="yes" translate="yes" xml:space="default">
        <source>I'm sure you've experienced this, and you know it's not fun.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517259</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="470" reformat="yes" translate="yes" xml:space="default">
        <source>With exceptions, errors occur immediately, and you can handle them in a standard way at the source of the problem.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517260</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="471" reformat="yes" translate="yes" xml:space="default">
        <source>Using Exceptions For Other Purposes</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517261</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="472" reformat="yes" translate="yes" xml:space="default">
        <source>There are a lot of other uses for exceptions besides handling actual error conditions.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517262</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="473" reformat="yes" translate="yes" xml:space="default">
        <source>A common use in the standard <ph id="1">&amp;python;</ph> library is to try to import a module, and then check whether it worked.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517263</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="474" reformat="yes" translate="yes" xml:space="default">
        <source>Importing a module that does not exist will raise an <ph id="1">&amp;importerror;</ph> exception.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517264</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="475" reformat="yes" translate="yes" xml:space="default">
        <source>You can use this to define multiple levels of functionality based on which modules are available at run-time, or to support multiple platforms (where platform-specific code is separated into different modules).</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517265</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="476" reformat="yes" translate="yes" xml:space="default">
        <source>You can also define your own exceptions by creating a class that inherits from the built-in <bpt id="1">&lt;classname&gt;</bpt>Exception<ept id="1">&lt;/classname&gt;</ept> class, and then raise your exceptions with the <bpt id="2">&lt;function&gt;</bpt>raise<ept id="2">&lt;/function&gt;</ept> command.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517266</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="477" reformat="yes" translate="yes" xml:space="default">
        <source>See the further reading section if you're interested in doing this.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517267</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="478" reformat="yes" translate="yes" xml:space="default">
        <source>The next example demonstrates how to use an exception to support platform-specific functionality.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517268</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="479" reformat="yes" translate="yes" xml:space="default">
        <source>This code comes from the <bpt id="1">&lt;filename class=&quot;headerfile&quot;&gt;</bpt>getpass<ept id="1">&lt;/filename&gt;</ept> module, a wrapper module for getting a password from the user.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517270</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="480" reformat="yes" translate="yes" xml:space="default">
        <source>Getting a password is accomplished differently on <ph id="1">&amp;unix;</ph>, <ph id="2">&amp;windows;</ph>, and <ph id="3">&amp;macos;</ph> platforms, but this code encapsulates all of those differences.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517271</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="481" reformat="yes" translate="yes" xml:space="default">
        <source>Supporting Platform-Specific Functionality</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517272</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="482" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;termios;</ph> is a <ph id="2">&amp;unix;</ph>-specific module that provides low-level control over the input terminal.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517273</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="483" reformat="yes" translate="yes" xml:space="default">
        <source>If this module is not available (because it's not on your system, or your system doesn't support it), the import fails and <ph id="1">&amp;python;</ph> raises an <ph id="2">&amp;importerror;</ph>, which you catch.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517274</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="484" reformat="yes" translate="yes" xml:space="default">
        <source>OK, you didn't have <ph id="1">&amp;termios;</ph>, so let's try <ph id="2">&amp;msvcrt;</ph>, which is a <ph id="3">&amp;windows;</ph>-specific module that provides an <ph id="4">&amp;api;</ph> to many useful functions in the Microsoft <bpt id="5">&lt;application&gt;</bpt>Visual C++<ept id="5">&lt;/application&gt;</ept> runtime services.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517275</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="485" reformat="yes" translate="yes" xml:space="default">
        <source>If this import fails, <ph id="1">&amp;python;</ph> will raise an <ph id="2">&amp;importerror;</ph>, which you catch.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517276</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="486" reformat="yes" translate="yes" xml:space="default">
        <source>If the first two didn't work, you try to import a function from <ph id="1">&amp;easydialogs;</ph>, which is a <ph id="2">&amp;macos;</ph>-specific module that provides functions to pop up dialog boxes of various types.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517277</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="487" reformat="yes" translate="yes" xml:space="default">
        <source>Once again, if this import fails, <ph id="1">&amp;python;</ph> will raise an <ph id="2">&amp;importerror;</ph>, which you catch.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517278</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="488" reformat="yes" translate="yes" xml:space="default">
        <source>None of these platform-specific modules is available (which is possible, since <ph id="1">&amp;python;</ph> has been ported to a lot of different platforms), so you need to fall back on a default password input function (which is defined elsewhere in the <ph id="2">&amp;getpass;</ph> module).</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517279</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="489" reformat="yes" translate="yes" xml:space="default">
        <source>Notice what you're doing here:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517280</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="490" reformat="yes" translate="yes" xml:space="default">
        <source>assigning the function <bpt id="1">&lt;function&gt;</bpt>default_getpass<ept id="1">&lt;/function&gt;</ept> to the variable <bpt id="2">&lt;varname&gt;</bpt>getpass<ept id="2">&lt;/varname&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517281</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="491" reformat="yes" translate="yes" xml:space="default">
        <source>If you read the official <ph id="1">&amp;getpass;</ph> documentation, it tells you that the <ph id="2">&amp;getpass;</ph> module defines a <bpt id="3">&lt;function&gt;</bpt>getpass<ept id="3">&lt;/function&gt;</ept> function.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517282</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="492" reformat="yes" translate="yes" xml:space="default">
        <source>It does this by binding <bpt id="1">&lt;varname&gt;</bpt>getpass<ept id="1">&lt;/varname&gt;</ept> to the correct function for your platform.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517283</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="493" reformat="yes" translate="yes" xml:space="default">
        <source>Then when you call the <bpt id="1">&lt;function&gt;</bpt>getpass<ept id="1">&lt;/function&gt;</ept> function, you're really calling a platform-specific function that this code has set up for you.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517284</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="494" reformat="yes" translate="yes" xml:space="default">
        <source>You don't need to know or care which platform your code is running on -- just call <bpt id="1">&lt;function&gt;</bpt>getpass<ept id="1">&lt;/function&gt;</ept>, and it will always do the right thing.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517285</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="495" reformat="yes" translate="yes" xml:space="default">
        <source>A <ph id="1">&amp;tryexcept;</ph> block can have an <ph id="2">&amp;else;</ph> clause, like an <ph id="3">&amp;if;</ph> statement.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517286</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="496" reformat="yes" translate="yes" xml:space="default">
        <source>If no exception is raised during the <bpt id="1">&lt;literal&gt;</bpt>try<ept id="1">&lt;/literal&gt;</ept> block, the <ph id="2">&amp;else;</ph> clause is executed afterwards.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517287</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="497" reformat="yes" translate="yes" xml:space="default">
        <source>In this case, that means that the <bpt id="1">&lt;literal&gt;</bpt>from EasyDialogs import AskPassword<ept id="1">&lt;/literal&gt;</ept> import worked, so you should bind <bpt id="2">&lt;varname&gt;</bpt>getpass<ept id="2">&lt;/varname&gt;</ept> to the <bpt id="3">&lt;function&gt;</bpt>AskPassword<ept id="3">&lt;/function&gt;</ept> function.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517291</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="498" reformat="yes" translate="yes" xml:space="default">
        <source>Each of the other <ph id="1">&amp;tryexcept;</ph> blocks has similar <ph id="2">&amp;else;</ph> clauses to bind <bpt id="3">&lt;varname&gt;</bpt>getpass<ept id="3">&lt;/varname&gt;</ept> to the appropriate function when you find an <ph id="4">&amp;import;</ph> that works.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517292</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="499" reformat="yes" translate="yes" xml:space="default">
        <source>Further Reading on Exception Handling</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517293</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="500" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;pythontutorial;</ph> discusses <bpt id="2">&lt;ulink url=&quot;&amp;url_pythontutorial;node10.html#SECTION0010400000000000000000&quot;&gt;</bpt>defining and raising your own exceptions, and handling multiple exceptions at once<ept id="2">&lt;/ulink&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517294</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="501" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;pythonlibraryreference;</ph> summarizes <bpt id="2">&lt;ulink url=&quot;&amp;url_pythonlibraryreference;module-exceptions.html&quot;&gt;</bpt>all the built-in exceptions<ept id="2">&lt;/ulink&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517296</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="502" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;pythonlibraryreference;</ph> documents the <bpt id="2">&lt;ulink url=&quot;&amp;url_pythonlibs;module-getpass.html&quot;&gt;</bpt>getpass<ept id="2">&lt;/ulink&gt;</ept> module.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517297</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="503" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;pythonlibraryreference;</ph> documents the <bpt id="2">&lt;ulink url=&quot;&amp;url_pythonlibraryreference;module-traceback.html&quot;&gt;</bpt>
          <bpt id="3">&lt;filename class=&quot;headerfile&quot;&gt;</bpt>traceback<ept id="3">&lt;/filename&gt;</ept> module<ept id="2">&lt;/ulink&gt;</ept>, which provides low-level access to exception attributes after an exception is raised.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517298</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="504" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;pythonlanguagereference;</ph> discusses the inner workings of the <bpt id="2">&lt;ulink url=&quot;&amp;url_pythonlanguagereference;try.html&quot;&gt;</bpt>
          <ph id="3">&amp;tryexcept;</ph> block<ept id="2">&lt;/ulink&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517299</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="505" reformat="yes" translate="yes" xml:space="default">
        <source>Working with File Objects</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517300</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="506" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph> has a built-in function, <ph id="2">&amp;open;</ph>, for opening a file on disk.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517301</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="507" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;open;</ph> returns a file object, which has methods and attributes for getting information about and manipulating the opened file.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517302</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="508" reformat="yes" translate="yes" xml:space="default">
        <source>Opening a File</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517303</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="509" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;open;</ph> method can take up to three parameters:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517304</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="510" reformat="yes" translate="yes" xml:space="default">
        <source>a filename, a mode, and a buffering parameter.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517305</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="511" reformat="yes" translate="yes" xml:space="default">
        <source>Only the first one, the filename, is required; the other two are <bpt id="1">&lt;link linkend=&quot;apihelper.optional&quot;&gt;</bpt>optional<ept id="1">&lt;/link&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517306</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="512" reformat="yes" translate="yes" xml:space="default">
        <source>If not specified, the file is opened for reading in text mode.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517307</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="513" reformat="yes" translate="yes" xml:space="default">
        <source>Here you are opening the file for reading in binary mode.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517308</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="514" reformat="yes" translate="yes" xml:space="default">
        <source>(<bpt id="1">&lt;literal&gt;</bpt>print open.__doc__<ept id="1">&lt;/literal&gt;</ept> displays a great explanation of all the possible modes.)</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517309</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="515" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;open;</ph> function returns an object (by now, <bpt id="2">&lt;link linkend=&quot;odbchelper.objects&quot;&gt;</bpt>this should not surprise you<ept id="2">&lt;/link&gt;</ept>).</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517310</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="516" reformat="yes" translate="yes" xml:space="default">
        <source>A file object has several useful attributes.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517311</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="517" reformat="yes" translate="yes" xml:space="default">
        <source>The <bpt id="1">&lt;varname&gt;</bpt>mode<ept id="1">&lt;/varname&gt;</ept> attribute of a file object tells you in which mode the file was opened.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517312</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="518" reformat="yes" translate="yes" xml:space="default">
        <source>The <bpt id="1">&lt;varname&gt;</bpt>name<ept id="1">&lt;/varname&gt;</ept> attribute of a file object tells you the name of the file that the file object has open.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517313</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="519" reformat="yes" translate="yes" xml:space="default">
        <source>Reading Files</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517314</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="520" reformat="yes" translate="yes" xml:space="default">
        <source>After you open a file, the first thing you'll want to do is read from it, as shown in the next example.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517315</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="521" reformat="yes" translate="yes" xml:space="default">
        <source>Reading a File</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517317</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="522" reformat="yes" translate="yes" xml:space="default">
        <source>A file object maintains state about the file it has open.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517318</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="523" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;tell;</ph> method of a file object tells you your current position in the open file.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517319</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="524" reformat="yes" translate="yes" xml:space="default">
        <source>Since you haven't done anything with this file yet, the current position is <ph id="1">&amp;zero;</ph>, which is the beginning of the file.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517320</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="525" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;seek;</ph> method of a file object moves to another position in the open file.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517321</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="526" reformat="yes" translate="yes" xml:space="default">
        <source>The second parameter specifies what the first one means; <ph id="1">&amp;zero;</ph> means move to an absolute position (counting from the start of the file), <ph id="2">&amp;one;</ph> means move to a relative position (counting from the current position), and <bpt id="3">&lt;literal&gt;</bpt>2<ept id="3">&lt;/literal&gt;</ept> means move to a position relative to the end of the file.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517322</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="527" reformat="yes" translate="yes" xml:space="default">
        <source>Since the <ph id="1">&amp;mp3;</ph> tags you're looking for are stored at the end of the file, you use <bpt id="2">&lt;literal&gt;</bpt>2<ept id="2">&lt;/literal&gt;</ept> and tell the file object to move to a position <bpt id="3">&lt;literal&gt;</bpt>128<ept id="3">&lt;/literal&gt;</ept> bytes from the end of the file.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517323</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="528" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;tell;</ph> method confirms that the current file position has moved.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517324</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="529" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;read;</ph> method reads a specified number of bytes from the open file and returns a string with the data that was read.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517325</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="530" reformat="yes" translate="yes" xml:space="default">
        <source>The optional parameter specifies the maximum number of bytes to read.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517326</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="531" reformat="yes" translate="yes" xml:space="default">
        <source>If no parameter is specified, <ph id="1">&amp;read;</ph> will read until the end of the file.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517327</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="532" reformat="yes" translate="yes" xml:space="default">
        <source>(You could have simply said <bpt id="1">&lt;literal&gt;</bpt>read()<ept id="1">&lt;/literal&gt;</ept> here, since you know exactly where you are in the file and you are, in fact, reading the last 128 bytes.) The read data is assigned to the <bpt id="2">&lt;varname&gt;</bpt>tagData<ept id="2">&lt;/varname&gt;</ept> variable, and the current position is updated based on how many bytes were read.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517328</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="533" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;tell;</ph> method confirms that the current position has moved.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517329</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="534" reformat="yes" translate="yes" xml:space="default">
        <source>If you do the math, you'll see that after reading 128 bytes, the position has been incremented by 128.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517330</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="535" reformat="yes" translate="yes" xml:space="default">
        <source>Closing Files</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517331</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="536" reformat="yes" translate="yes" xml:space="default">
        <source>Open files consume system resources, and depending on the file mode, other programs may not be able to access them.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517332</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="537" reformat="yes" translate="yes" xml:space="default">
        <source>It's important to close files as soon as you're finished with them.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517333</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="538" reformat="yes" translate="yes" xml:space="default">
        <source>Closing a File</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517334</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="539" reformat="yes" translate="yes" xml:space="default">
        <source>The <bpt id="1">&lt;varname&gt;</bpt>closed<ept id="1">&lt;/varname&gt;</ept> attribute of a file object indicates whether the object has a file open or not.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517335</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="540" reformat="yes" translate="yes" xml:space="default">
        <source>In this case, the file is still open (<bpt id="1">&lt;varname&gt;</bpt>closed<ept id="1">&lt;/varname&gt;</ept> is <ph id="2">&amp;false;</ph>).</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517336</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="541" reformat="yes" translate="yes" xml:space="default">
        <source>To close a file, call the <ph id="1">&amp;close;</ph> method of the file object.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517337</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="542" reformat="yes" translate="yes" xml:space="default">
        <source>This frees the lock (if any) that you were holding on the file, flushes buffered writes (if any) that the system hadn't gotten around to actually writing yet, and releases the system resources.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517338</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="543" reformat="yes" translate="yes" xml:space="default">
        <source>The <bpt id="1">&lt;varname&gt;</bpt>closed<ept id="1">&lt;/varname&gt;</ept> attribute confirms that the file is closed.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517339</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="544" reformat="yes" translate="yes" xml:space="default">
        <source>Just because a file is closed doesn't mean that the file object ceases to exist.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517340</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="545" reformat="yes" translate="yes" xml:space="default">
        <source>The variable <bpt id="1">&lt;varname&gt;</bpt>f<ept id="1">&lt;/varname&gt;</ept> will continue to exist until it <bpt id="2">&lt;link linkend=&quot;fileinfo.scope&quot;&gt;</bpt>goes out of scope<ept id="2">&lt;/link&gt;</ept> or gets manually deleted.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517341</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="546" reformat="yes" translate="yes" xml:space="default">
        <source>However, none of the methods that manipulate an open file will work once the file has been closed; they all raise an exception.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517342</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="547" reformat="yes" translate="yes" xml:space="default">
        <source>Calling <ph id="1">&amp;close;</ph> on a file object whose file is already closed does <bpt id="2">&lt;emphasis&gt;</bpt>not<ept id="2">&lt;/emphasis&gt;</ept> raise an exception; it fails silently.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517343</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="548" reformat="yes" translate="yes" xml:space="default">
        <source>Handling <bpt id="1">&lt;acronym&gt;</bpt>I/O<ept id="1">&lt;/acronym&gt;</ept> Errors</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517344</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="549" reformat="yes" translate="yes" xml:space="default">
        <source>Now you've seen enough to understand the file handling code in the <ph id="1">&amp;fileinfo_filename;</ph> sample code from teh previous chapter.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517345</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="550" reformat="yes" translate="yes" xml:space="default">
        <source>This example shows how to safely open and read from a file and gracefully handle errors.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517346</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="551" reformat="yes" translate="yes" xml:space="default">
        <source>File Objects in <ph id="1">&amp;mp3fileinfo_classname;</ph>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517347</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="552" reformat="yes" translate="yes" xml:space="default">
        <source>Because opening and reading files is risky and may raise an exception, all of this code is wrapped in a <ph id="1">&amp;tryexcept;</ph> block.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517348</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="553" reformat="yes" translate="yes" xml:space="default">
        <source>(Hey, isn't <bpt id="1">&lt;link linkend=&quot;odbchelper.indenting&quot;&gt;</bpt>standardized indentation<ept id="1">&lt;/link&gt;</ept> great?</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517349</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="554" reformat="yes" translate="yes" xml:space="default">
        <source>This is where you start to appreciate it.)</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517350</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="555" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;open;</ph> function may raise an <ph id="2">&amp;ioerror;</ph>. (Maybe the file doesn't exist.)</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517351</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="556" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;seek;</ph> method may raise an <ph id="2">&amp;ioerror;</ph>. (Maybe the file is smaller than 128 bytes.)</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517352</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="557" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;read;</ph> method may raise an <ph id="2">&amp;ioerror;</ph>. (Maybe the disk has a bad sector, or it's on a network drive and the network just went down.)</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517353</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="558" reformat="yes" translate="yes" xml:space="default">
        <source>This is new:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517354</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="559" reformat="yes" translate="yes" xml:space="default">
        <source>a <ph id="1">&amp;tryfinally;</ph> block.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517355</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="560" reformat="yes" translate="yes" xml:space="default">
        <source>Once the file has been opened successfully by the <ph id="1">&amp;open;</ph> function, you want to make absolutely sure that you close it, even if an exception is raised by the <ph id="2">&amp;seek;</ph> or <ph id="3">&amp;read;</ph> methods.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517356</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="561" reformat="yes" translate="yes" xml:space="default">
        <source>That's what a <ph id="1">&amp;tryfinally;</ph> block is for:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517357</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="562" reformat="yes" translate="yes" xml:space="default">
        <source>code in the <bpt id="1">&lt;literal&gt;</bpt>finally<ept id="1">&lt;/literal&gt;</ept> block will <bpt id="2">&lt;emphasis&gt;</bpt>always<ept id="2">&lt;/emphasis&gt;</ept> be executed, even if something in the <bpt id="3">&lt;literal&gt;</bpt>try<ept id="3">&lt;/literal&gt;</ept> block raises an exception.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517358</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="563" reformat="yes" translate="yes" xml:space="default">
        <source>Think of it as code that gets executed on the way out, regardless of what happened before.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517359</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="564" reformat="yes" translate="yes" xml:space="default">
        <source>At last, you handle your <ph id="1">&amp;ioerror;</ph> exception.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517360</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="565" reformat="yes" translate="yes" xml:space="default">
        <source>This could be the <ph id="1">&amp;ioerror;</ph> exception raised by the call to <ph id="2">&amp;open;</ph>, <ph id="3">&amp;seek;</ph>, or <ph id="4">&amp;read;</ph>. Here, you really don't care, because all you're going to do is ignore it silently and continue.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517361</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="566" reformat="yes" translate="yes" xml:space="default">
        <source>(Remember, <ph id="1">&amp;pass;</ph> is a <ph id="2">&amp;python;</ph> statement that <bpt id="3">&lt;link linkend=&quot;fileinfo.class.simplest&quot;&gt;</bpt>does nothing<ept id="3">&lt;/link&gt;</ept>.) That's perfectly legal; <bpt id="4">&lt;quote&gt;</bpt>handling<ept id="4">&lt;/quote&gt;</ept> an exception can mean explicitly doing nothing.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517362</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="567" reformat="yes" translate="yes" xml:space="default">
        <source>It still counts as handled, and processing will continue normally on the next line of code after the <ph id="1">&amp;tryexcept;</ph> block.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517363</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="568" reformat="yes" translate="yes" xml:space="default">
        <source>Writing to Files</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517364</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="569" reformat="yes" translate="yes" xml:space="default">
        <source>As you would expect, you can also write to files in much the same way that you read from them.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517365</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="570" reformat="yes" translate="yes" xml:space="default">
        <source>There are two basic file modes:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517366</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="571" reformat="yes" translate="yes" xml:space="default">
        <source>&quot;Append&quot; mode will add data to the end of the file.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517367</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="572" reformat="yes" translate="yes" xml:space="default">
        <source>&quot;write&quot; mode will overwrite the file.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517368</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="573" reformat="yes" translate="yes" xml:space="default">
        <source>Either mode will create the file automatically if it doesn't already exist, so there's never a need for any sort of fiddly &quot;if the log file doesn't exist yet, create a new empty file just so you can open it for the first time&quot; logic.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517369</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="574" reformat="yes" translate="yes" xml:space="default">
        <source>Just open it and start writing.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517370</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="575" reformat="yes" translate="yes" xml:space="default">
        <source>Writing to Files</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517371</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="576" reformat="yes" translate="yes" xml:space="default">
        <source>You start boldly by creating either the new file <bpt id="1">&lt;filename&gt;</bpt>test.log<ept id="1">&lt;/filename&gt;</ept> or overwrites the existing file, and opening the file for writing.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517372</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="577" reformat="yes" translate="yes" xml:space="default">
        <source>(The second parameter <bpt id="1">&lt;literal&gt;</bpt>&quot;w&quot;<ept id="1">&lt;/literal&gt;</ept> means open the file for writing.) Yes, that's all as dangerous as it sounds.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517373</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="578" reformat="yes" translate="yes" xml:space="default">
        <source>I hope you didn't care about the previous contents of that file, because it's gone now.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517374</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="579" reformat="yes" translate="yes" xml:space="default">
        <source>You can add data to the newly opened file with the <ph id="1">&amp;write;</ph> method of the file object returned by <ph id="2">&amp;open;</ph>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517375</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="580" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;file;</ph> is a synonym for <ph id="2">&amp;open;</ph>. This one-liner opens the file, reads its contents, and prints them.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517376</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="581" reformat="yes" translate="yes" xml:space="default">
        <source>You happen to know that <bpt id="1">&lt;filename&gt;</bpt>test.log<ept id="1">&lt;/filename&gt;</ept> exists (since you just finished writing to it), so you can open it and append to it.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517377</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="582" reformat="yes" translate="yes" xml:space="default">
        <source>(The <bpt id="1">&lt;literal&gt;</bpt>&quot;a&quot;<ept id="1">&lt;/literal&gt;</ept> parameter means open the file for appending.) Actually you could do this even if the file didn't exist, because opening the file for appending will create the file if necessary.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517378</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="583" reformat="yes" translate="yes" xml:space="default">
        <source>But appending will <bpt id="1">&lt;emphasis&gt;</bpt>never<ept id="1">&lt;/emphasis&gt;</ept> harm the existing contents of the file.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517379</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="584" reformat="yes" translate="yes" xml:space="default">
        <source>As you can see, both the original line you wrote and the second line you appended are now in <bpt id="1">&lt;filename&gt;</bpt>test.log<ept id="1">&lt;/filename&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517381</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="585" reformat="yes" translate="yes" xml:space="default">
        <source>Also note that carriage returns are not included.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517382</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="586" reformat="yes" translate="yes" xml:space="default">
        <source>Since you didn't write them explicitly to the file either time, the file doesn't include them.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517383</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="587" reformat="yes" translate="yes" xml:space="default">
        <source>You can write a carriage return with the <bpt id="1">&lt;literal&gt;</bpt>&quot;\n&quot;<ept id="1">&lt;/literal&gt;</ept> character.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517384</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="588" reformat="yes" translate="yes" xml:space="default">
        <source>Since you didn't do this, everything you wrote to the file ended up smooshed together on the same line.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517385</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="589" reformat="yes" translate="yes" xml:space="default">
        <source>Further Reading on File Handling</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517386</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="590" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;pythontutorial;</ph> discusses reading and writing files, including how to <bpt id="2">&lt;ulink url=&quot;&amp;url_pythontutorial;node9.html#SECTION009210000000000000000&quot;&gt;</bpt>read a file one line at a time into a list<ept id="2">&lt;/ulink&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517387</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="591" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;effbot;</ph> discusses efficiency and performance of <bpt id="2">&lt;ulink url=&quot;&amp;url_effbot;readline-performance.htm&quot;&gt;</bpt>various ways of reading a file<ept id="2">&lt;/ulink&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517388</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="592" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;pythonknowledgebase;</ph> answers <bpt id="2">&lt;ulink url=&quot;&amp;url_pythonknowledgebase;index.phtml/fid/552&quot;&gt;</bpt>common questions about files<ept id="2">&lt;/ulink&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517389</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="593" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;pythonlibraryreference;</ph> summarizes <bpt id="2">&lt;ulink url=&quot;&amp;url_pythonlibraryreference;bltin-file-objects.html&quot;&gt;</bpt>all the file object methods<ept id="2">&lt;/ulink&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517390</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="594" reformat="yes" translate="yes" xml:space="default">
        <source>Iterating with <ph id="1">&amp;for;</ph> Loops</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517391</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="595" reformat="yes" translate="yes" xml:space="default">
        <source>Like most other languages, <ph id="1">&amp;python;</ph> has <ph id="2">&amp;for;</ph> loops.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517392</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="596" reformat="yes" translate="yes" xml:space="default">
        <source>The only reason you haven't seen them until now is that <ph id="1">&amp;python;</ph> is good at so many other things that you don't need them as often.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517393</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="597" reformat="yes" translate="yes" xml:space="default">
        <source>Most other languages don't have a powerful list datatype like <ph id="1">&amp;python;</ph>, so you end up doing a lot of manual work, specifying a start, end, and step to define a range of integers or characters or other iteratable entities.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517394</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="598" reformat="yes" translate="yes" xml:space="default">
        <source>But in <ph id="1">&amp;python;</ph>, a <ph id="2">&amp;for;</ph> loop simply iterates over a list, the same way <bpt id="3">&lt;link linkend=&quot;odbchelper.map&quot;&gt;</bpt>list comprehensions<ept id="3">&lt;/link&gt;</ept> work.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517395</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="599" reformat="yes" translate="yes" xml:space="default">
        <source>Introducing the <ph id="1">&amp;for;</ph> Loop</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517396</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="600" reformat="yes" translate="yes" xml:space="default">
        <source>The syntax for a <ph id="1">&amp;for;</ph> loop is similar to <bpt id="2">&lt;link linkend=&quot;odbchelper.map&quot;&gt;</bpt>list comprehensions<ept id="2">&lt;/link&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517397</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="601" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;varname&gt;</bpt>li<ept id="1">&lt;/varname&gt;</ept> is a list, and <bpt id="2">&lt;varname&gt;</bpt>s<ept id="2">&lt;/varname&gt;</ept> will take the value of each element in turn, starting from the first element.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517398</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="602" reformat="yes" translate="yes" xml:space="default">
        <source>Like an <ph id="1">&amp;if;</ph> statement or any other <bpt id="2">&lt;link linkend=&quot;odbchelper.indenting&quot;&gt;</bpt>indented block<ept id="2">&lt;/link&gt;</ept>, a <ph id="3">&amp;for;</ph> loop can have any number of lines of code in it.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517399</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="603" reformat="yes" translate="yes" xml:space="default">
        <source>This is the reason you haven't seen the <ph id="1">&amp;for;</ph> loop yet:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517400</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="604" reformat="yes" translate="yes" xml:space="default">
        <source>you haven't needed it yet.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517401</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="605" reformat="yes" translate="yes" xml:space="default">
        <source>It's amazing how often you use <ph id="1">&amp;for;</ph> loops in other languages when all you really want is a <ph id="2">&amp;join;</ph> or a list comprehension.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517402</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="606" reformat="yes" translate="yes" xml:space="default">
        <source>Doing a <bpt id="1">&lt;quote&gt;</bpt>normal<ept id="1">&lt;/quote&gt;</ept> (by <ph id="2">&amp;vb;</ph> standards) counter <ph id="3">&amp;for;</ph> loop is also simple.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517403</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="607" reformat="yes" translate="yes" xml:space="default">
        <source>Simple Counters</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517404</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="608" reformat="yes" translate="yes" xml:space="default">
        <source>As you saw in <ph id="1">&lt;xref linkend=&quot;odbchelper.multiassign.range&quot;/&gt;</ph>, <ph id="2">&amp;range;</ph> produces a list of integers, which you then loop through.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517405</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="609" reformat="yes" translate="yes" xml:space="default">
        <source>I know it looks a bit odd, but it is occasionally (and I stress <bpt id="1">&lt;emphasis&gt;</bpt>occasionally<ept id="1">&lt;/emphasis&gt;</ept>) useful to have a counter loop.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517406</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="610" reformat="yes" translate="yes" xml:space="default">
        <source>Don't ever do this.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517407</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="611" reformat="yes" translate="yes" xml:space="default">
        <source>This is <ph id="1">&amp;vb;</ph>-style thinking.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517408</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="612" reformat="yes" translate="yes" xml:space="default">
        <source>Break out of it.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517409</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="613" reformat="yes" translate="yes" xml:space="default">
        <source>Just iterate through the list, as shown in the previous example.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517410</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="614" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;for;</ph> loops are not just for simple counters.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517411</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="615" reformat="yes" translate="yes" xml:space="default">
        <source>They can iterate through all kinds of things.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517412</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="616" reformat="yes" translate="yes" xml:space="default">
        <source>Here is an example of using a <ph id="1">&amp;for;</ph> loop to iterate through a dictionary.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517413</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="617" reformat="yes" translate="yes" xml:space="default">
        <source>Iterating Through a Dictionary</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517414</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="618" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;varname&gt;</bpt>os.environ<ept id="1">&lt;/varname&gt;</ept> is a dictionary of the environment variables defined on your system.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517415</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="619" reformat="yes" translate="yes" xml:space="default">
        <source>In <ph id="1">&amp;windows;</ph>, these are your user and system variables accessible from <ph id="2">&amp;dos;</ph>. In <ph id="3">&amp;unix;</ph>, they are the variables exported in your shell's startup scripts.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517416</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="620" reformat="yes" translate="yes" xml:space="default">
        <source>In <ph id="1">&amp;macos;</ph>, there is no concept of environment variables, so this dictionary is empty.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517417</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="621" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;literal&gt;</bpt>os.environ.items()<ept id="1">&lt;/literal&gt;</ept> returns a list of tuples:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517418</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="622" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;literal&gt;</bpt>[(<bpt id="2">&lt;replaceable&gt;</bpt>key1<ept id="2">&lt;/replaceable&gt;</ept>, <bpt id="3">&lt;replaceable&gt;</bpt>value1<ept id="3">&lt;/replaceable&gt;</ept>), (<bpt id="4">&lt;replaceable&gt;</bpt>key2<ept id="4">&lt;/replaceable&gt;</ept>, <bpt id="5">&lt;replaceable&gt;</bpt>value2<ept id="5">&lt;/replaceable&gt;</ept>), ...]<ept id="1">&lt;/literal&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517419</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="623" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;for;</ph> loop iterates through this list.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517420</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="624" reformat="yes" translate="yes" xml:space="default">
        <source>The first round, it assigns <bpt id="1">&lt;literal&gt;</bpt>
          <bpt id="2">&lt;replaceable&gt;</bpt>key1<ept id="2">&lt;/replaceable&gt;</ept>
          <ept id="1">&lt;/literal&gt;</ept> to <bpt id="3">&lt;varname&gt;</bpt>k<ept id="3">&lt;/varname&gt;</ept> and <bpt id="4">&lt;literal&gt;</bpt>
          <bpt id="5">&lt;replaceable&gt;</bpt>value1<ept id="5">&lt;/replaceable&gt;</ept>
          <ept id="4">&lt;/literal&gt;</ept> to <bpt id="6">&lt;varname&gt;</bpt>v<ept id="6">&lt;/varname&gt;</ept>, so <bpt id="7">&lt;varname&gt;</bpt>k<ept id="7">&lt;/varname&gt;</ept> = <bpt id="8">&lt;literal&gt;</bpt>USERPROFILE<ept id="8">&lt;/literal&gt;</ept> and <bpt id="9">&lt;varname&gt;</bpt>v<ept id="9">&lt;/varname&gt;</ept> = <bpt id="10">&lt;literal&gt;</bpt>C:\Documents and Settings\mpilgrim<ept id="10">&lt;/literal&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517421</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="625" reformat="yes" translate="yes" xml:space="default">
        <source>In the second round, <bpt id="1">&lt;varname&gt;</bpt>k<ept id="1">&lt;/varname&gt;</ept> gets the second key, <bpt id="2">&lt;literal&gt;</bpt>OS<ept id="2">&lt;/literal&gt;</ept>, and <bpt id="3">&lt;varname&gt;</bpt>v<ept id="3">&lt;/varname&gt;</ept> gets the corresponding value, <bpt id="4">&lt;literal&gt;</bpt>Windows_NT<ept id="4">&lt;/literal&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517422</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="626" reformat="yes" translate="yes" xml:space="default">
        <source>With <bpt id="1">&lt;link linkend=&quot;odbchelper.multiassign&quot;&gt;</bpt>multi-variable assignment<ept id="1">&lt;/link&gt;</ept> and <bpt id="2">&lt;link linkend=&quot;odbchelper.map&quot;&gt;</bpt>list comprehensions<ept id="2">&lt;/link&gt;</ept>, you can replace the entire <ph id="3">&amp;for;</ph> loop with a single statement.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517423</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="627" reformat="yes" translate="yes" xml:space="default">
        <source>Whether you actually do this in real code is a matter of personal coding style.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517424</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="628" reformat="yes" translate="yes" xml:space="default">
        <source>I like it because it makes it clear that what I'm doing is mapping a dictionary into a list, then joining the list into a single string.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517425</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="629" reformat="yes" translate="yes" xml:space="default">
        <source>Other programmers prefer to write this out as a <ph id="1">&amp;for;</ph> loop.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517426</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="630" reformat="yes" translate="yes" xml:space="default">
        <source>The output is the same in either case, although this version is slightly faster, because there is only one <ph id="1">&amp;print;</ph> statement instead of many.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517427</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="631" reformat="yes" translate="yes" xml:space="default">
        <source>Now we can look at the <ph id="1">&amp;for;</ph> loop in <bpt id="2">&lt;classname&gt;</bpt>MP3FileInfo<ept id="2">&lt;/classname&gt;</ept>, from the sample <ph id="3">&amp;fileinfo_filename;</ph> program introduced in <ph id="4">&lt;xref linkend=&quot;fileinfo&quot; endterm=&quot;fileinfo.numberonly&quot;/&gt;</ph>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517428</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="632" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;for;</ph> Loop in <ph id="2">&amp;mp3fileinfo_classname;</ph>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517429</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="633" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;tagdatamap;</ph> is a <bpt id="2">&lt;link linkend=&quot;fileinfo.classattributes&quot;&gt;</bpt>class attribute<ept id="2">&lt;/link&gt;</ept> that defines the tags you're looking for in an <ph id="3">&amp;mp3;</ph> file.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517430</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="634" reformat="yes" translate="yes" xml:space="default">
        <source>Tags are stored in fixed-length fields.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517431</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="635" reformat="yes" translate="yes" xml:space="default">
        <source>Once you read the last 128 bytes of the file, bytes 3 through 32 of those are always the song title, 33 through 62 are always the artist name, 63 through 92 are the album name, and so forth.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517432</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="636" reformat="yes" translate="yes" xml:space="default">
        <source>Note that <ph id="1">&amp;tagdatamap;</ph> is a dictionary of tuples, and each tuple contains two integers and a function reference.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517433</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="637" reformat="yes" translate="yes" xml:space="default">
        <source>This looks complicated, but it's not.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517434</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="638" reformat="yes" translate="yes" xml:space="default">
        <source>The structure of the <ph id="1">&amp;for;</ph> variables matches the structure of the elements of the list returned by <ph id="2">&amp;items;</ph>. Remember that <ph id="3">&amp;items;</ph> returns a list of tuples of the form <bpt id="4">&lt;literal&gt;</bpt>(<bpt id="5">&lt;replaceable&gt;</bpt>key<ept id="5">&lt;/replaceable&gt;</ept>, <bpt id="6">&lt;replaceable&gt;</bpt>value<ept id="6">&lt;/replaceable&gt;</ept>)<ept id="4">&lt;/literal&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517435</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="639" reformat="yes" translate="yes" xml:space="default">
        <source>The first element of that list is <bpt id="1">&lt;literal&gt;</bpt>(&quot;title&quot;, (3, 33, &lt;function stripnulls&gt;))<ept id="1">&lt;/literal&gt;</ept>, so the first time around the loop, <bpt id="2">&lt;varname&gt;</bpt>tag<ept id="2">&lt;/varname&gt;</ept> gets <bpt id="3">&lt;literal&gt;</bpt>&quot;title&quot;<ept id="3">&lt;/literal&gt;</ept>, <bpt id="4">&lt;varname&gt;</bpt>start<ept id="4">&lt;/varname&gt;</ept> gets <bpt id="5">&lt;literal&gt;</bpt>3<ept id="5">&lt;/literal&gt;</ept>, <bpt id="6">&lt;varname&gt;</bpt>end<ept id="6">&lt;/varname&gt;</ept> gets <bpt id="7">&lt;literal&gt;</bpt>33<ept id="7">&lt;/literal&gt;</ept>, and <bpt id="8">&lt;varname&gt;</bpt>parseFunc<ept id="8">&lt;/varname&gt;</ept> gets the function <bpt id="9">&lt;function&gt;</bpt>stripnulls<ept id="9">&lt;/function&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517436</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="640" reformat="yes" translate="yes" xml:space="default">
        <source>Now that you've extracted all the parameters for a single <ph id="1">&amp;mp3;</ph> tag, saving the tag data is easy.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517437</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="641" reformat="yes" translate="yes" xml:space="default">
        <source>You <bpt id="1">&lt;link linkend=&quot;odbchelper.list.slice&quot;&gt;</bpt>slice<ept id="1">&lt;/link&gt;</ept>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517438</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="642" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;varname&gt;</bpt>tagdata<ept id="1">&lt;/varname&gt;</ept> from <bpt id="2">&lt;varname&gt;</bpt>start<ept id="2">&lt;/varname&gt;</ept> to <bpt id="3">&lt;varname&gt;</bpt>end<ept id="3">&lt;/varname&gt;</ept> to get the actual data for this tag, call <bpt id="4">&lt;varname&gt;</bpt>parseFunc<ept id="4">&lt;/varname&gt;</ept> to post-process the data, and assign this as the value for the key <bpt id="5">&lt;varname&gt;</bpt>tag<ept id="5">&lt;/varname&gt;</ept> in the pseudo-dictionary <bpt id="6">&lt;varname&gt;</bpt>self<ept id="6">&lt;/varname&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517439</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="643" reformat="yes" translate="yes" xml:space="default">
        <source>After iterating through all the elements in <ph id="1">&amp;tagdatamap;</ph>, <bpt id="2">&lt;varname&gt;</bpt>self<ept id="2">&lt;/varname&gt;</ept> has the values for all the tags, and <bpt id="3">&lt;link linkend=&quot;fileinfo.specialmethods.setname&quot;&gt;</bpt>you know what that looks like<ept id="3">&lt;/link&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517440</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="644" reformat="yes" translate="yes" xml:space="default">
        <source>Using <ph id="1">&amp;sysmodules;</ph>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517441</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="645" reformat="yes" translate="yes" xml:space="default">
        <source>Modules, like everything else in <ph id="1">&amp;python;</ph>, are objects.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517442</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="646" reformat="yes" translate="yes" xml:space="default">
        <source>Once imported, you can always get a reference to a module through the global dictionary <ph id="1">&amp;sysmodules;</ph>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517443</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="647" reformat="yes" translate="yes" xml:space="default">
        <source>Introducing <ph id="1">&amp;sysmodules;</ph>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517444</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="648" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;sys;</ph> module contains system-level information, such as the version of <ph id="2">&amp;python;</ph> you're running (<bpt id="3">&lt;literal&gt;</bpt>
          <ph id="4">&amp;sys;</ph>.version<ept id="3">&lt;/literal&gt;</ept> or <bpt id="5">&lt;literal&gt;</bpt>
          <ph id="6">&amp;sys;</ph>.version_info<ept id="5">&lt;/literal&gt;</ept>), and system-level options such as the maximum allowed recursion depth (<bpt id="7">&lt;literal&gt;</bpt>
          <ph id="8">&amp;sys;</ph>.getrecursionlimit()<ept id="7">&lt;/literal&gt;</ept> and <bpt id="9">&lt;literal&gt;</bpt>
          <ph id="10">&amp;sys;</ph>.setrecursionlimit()<ept id="9">&lt;/literal&gt;</ept>).</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517449</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="649" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;sysmodules;</ph> is a dictionary containing all the modules that have ever been imported since <ph id="2">&amp;python;</ph> was started; the key is the module name, the value is the module object.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517450</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="650" reformat="yes" translate="yes" xml:space="default">
        <source>Note that this is more than just the modules <bpt id="1">&lt;emphasis&gt;</bpt>your<ept id="1">&lt;/emphasis&gt;</ept> program has imported.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517451</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="651" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph> preloads some modules on startup, and if you're using a <ph id="2">&amp;python;</ph>
          <ph id="3">&amp;ide;</ph>, <ph id="4">&amp;sysmodules;</ph> contains all the modules imported by all the programs you've run within the <ph id="5">&amp;ide;</ph>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517452</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="652" reformat="yes" translate="yes" xml:space="default">
        <source>This example demonstrates how to use <ph id="1">&amp;sysmodules;</ph>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517453</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="653" reformat="yes" translate="yes" xml:space="default">
        <source>Using <ph id="1">&amp;sysmodules;</ph>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517454</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="654" reformat="yes" translate="yes" xml:space="default">
        <source>As new modules are imported, they are added to <ph id="1">&amp;sysmodules;</ph>. This explains why importing the same module twice is very fast:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517455</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="655" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;python;</ph> has already loaded and cached the module in <ph id="2">&amp;sysmodules;</ph>, so importing the second time is simply a dictionary lookup.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517456</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="656" reformat="yes" translate="yes" xml:space="default">
        <source>Given the name (as a string) of any previously-imported module, you can get a reference to the module itself through the <ph id="1">&amp;sysmodules;</ph> dictionary.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517457</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="657" reformat="yes" translate="yes" xml:space="default">
        <source>The next example shows how to use the <bpt id="1">&lt;literal&gt;</bpt>__module__<ept id="1">&lt;/literal&gt;</ept> class attribute with the <ph id="2">&amp;sysmodules;</ph> dictionary to get a reference to the module in which a class is defined.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517458</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="658" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;moduleattr;</ph> Class Attribute</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517459</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="659" reformat="yes" translate="yes" xml:space="default">
        <source>Every <ph id="1">&amp;python;</ph> class has a built-in <bpt id="2">&lt;link linkend=&quot;fileinfo.classattributes&quot;&gt;</bpt>class attribute<ept id="2">&lt;/link&gt;</ept>
          <ph id="3">&amp;moduleattr;</ph>, which is the name of the module in which the class is defined.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517460</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="660" reformat="yes" translate="yes" xml:space="default">
        <source>Combining this with the <ph id="1">&amp;sysmodules;</ph> dictionary, you can get a reference to the module in which a class is defined.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517461</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="661" reformat="yes" translate="yes" xml:space="default">
        <source>Now you're ready to see how <ph id="1">&amp;sysmodules;</ph> is used in <ph id="2">&amp;fileinfo_filename;</ph>, the sample program introduced in <ph id="3">&lt;xref linkend=&quot;fileinfo&quot; endterm=&quot;fileinfo.numberonly&quot;/&gt;</ph>. This example shows that portion of the code.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517462</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="662" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;sysmodules;</ph> in <ph id="2">&amp;fileinfo_filename;</ph>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517463</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="663" reformat="yes" translate="yes" xml:space="default">
        <source>This is a function with two arguments; <bpt id="1">&lt;varname&gt;</bpt>filename<ept id="1">&lt;/varname&gt;</ept> is required, but <bpt id="2">&lt;varname&gt;</bpt>module<ept id="2">&lt;/varname&gt;</ept> is <bpt id="3">&lt;link linkend=&quot;apihelper.optional&quot;&gt;</bpt>optional<ept id="3">&lt;/link&gt;</ept> and defaults to the module that contains the <bpt id="4">&lt;classname&gt;</bpt>FileInfo<ept id="4">&lt;/classname&gt;</ept> class.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517464</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="664" reformat="yes" translate="yes" xml:space="default">
        <source>This looks inefficient, because you might expect <ph id="1">&amp;python;</ph> to evaluate the <ph id="2">&amp;sysmodules;</ph> expression every time the function is called.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517465</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="665" reformat="yes" translate="yes" xml:space="default">
        <source>In fact, <ph id="1">&amp;python;</ph> evaluates default expressions only once, the first time the module is imported.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517466</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="666" reformat="yes" translate="yes" xml:space="default">
        <source>As you'll see later, you never call this function with a <bpt id="1">&lt;varname&gt;</bpt>module<ept id="1">&lt;/varname&gt;</ept> argument, so <bpt id="2">&lt;varname&gt;</bpt>module<ept id="2">&lt;/varname&gt;</ept> serves as a function-level constant.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517467</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="667" reformat="yes" translate="yes" xml:space="default">
        <source>You'll plow through this line later, after you dive into the <ph id="1">&amp;os;</ph> module.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517468</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="668" reformat="yes" translate="yes" xml:space="default">
        <source>For now, take it on faith that <bpt id="1">&lt;varname&gt;</bpt>subclass<ept id="1">&lt;/varname&gt;</ept> ends up as the name of a class, like <bpt id="2">&lt;classname&gt;</bpt>MP3FileInfo<ept id="2">&lt;/classname&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517469</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="669" reformat="yes" translate="yes" xml:space="default">
        <source>You already know about <bpt id="1">&lt;link linkend=&quot;apihelper.getattr&quot;&gt;</bpt>
          <ph id="2">&amp;getattr;</ph>
          <ept id="1">&lt;/link&gt;</ept>, which gets a reference to an object by name.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517470</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="670" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;hasattr;</ph> is a complementary function that checks whether an object has a particular attribute; in this case, whether a module has a particular class (although it works for any object and any attribute, just like <ph id="2">&amp;getattr;</ph>). In English, this line of code says, <bpt id="3">&lt;quote&gt;</bpt>If this module has the class named by <bpt id="4">&lt;varname&gt;</bpt>subclass<ept id="4">&lt;/varname&gt;</ept> then return it, otherwise return the base class <bpt id="5">&lt;classname&gt;</bpt>FileInfo<ept id="5">&lt;/classname&gt;</ept>.<ept id="3">&lt;/quote&gt;</ept>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517471</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="671" reformat="yes" translate="yes" xml:space="default">
        <source>Further Reading on Modules</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517472</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="672" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;pythontutorial;</ph> discusses exactly <bpt id="2">&lt;ulink url=&quot;&amp;url_pythontutorial;node6.html#SECTION006710000000000000000&quot;&gt;</bpt>when and how default arguments are evaluated<ept id="2">&lt;/ulink&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517473</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="673" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;pythonlibraryreference;</ph> documents the <bpt id="2">&lt;ulink url=&quot;&amp;url_pythonlibraryreference;module-sys.html&quot;&gt;</bpt>
          <ph id="3">&amp;sys;</ph>
          <ept id="2">&lt;/ulink&gt;</ept> module.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517474</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="674" reformat="yes" translate="yes" xml:space="default">
        <source>Working with Directories</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517475</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="675" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;ospath;</ph> module has several functions for manipulating files and directories.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517476</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="676" reformat="yes" translate="yes" xml:space="default">
        <source>Here, we're looking at handling pathnames and listing the contents of a directory.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517477</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="677" reformat="yes" translate="yes" xml:space="default">
        <source>Constructing Pathnames</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517478</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="678" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;ospath;</ph> is a reference to a module -- which module depends on your platform.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517479</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="679" reformat="yes" translate="yes" xml:space="default">
        <source>Just as <bpt id="1">&lt;link linkend=&quot;crossplatform.example&quot;&gt;</bpt>
          <ph id="2">&amp;getpass;</ph>
          <ept id="1">&lt;/link&gt;</ept> encapsulates differences between platforms by setting <bpt id="3">&lt;varname&gt;</bpt>getpass<ept id="3">&lt;/varname&gt;</ept> to a platform-specific function, <ph id="4">&amp;os;</ph> encapsulates differences between platforms by setting <bpt id="5">&lt;varname&gt;</bpt>path<ept id="5">&lt;/varname&gt;</ept> to a platform-specific module.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517480</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="680" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;join;</ph> function of <ph id="2">&amp;ospath;</ph> constructs a pathname out of one or more partial pathnames.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517481</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="681" reformat="yes" translate="yes" xml:space="default">
        <source>In this case, it simply concatenates strings.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517482</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="682" reformat="yes" translate="yes" xml:space="default">
        <source>(Note that dealing with pathnames on <ph id="1">&amp;windows;</ph> is annoying because the backslash character must be escaped.)</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517483</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="683" reformat="yes" translate="yes" xml:space="default">
        <source>In this slightly less trivial case, <ph id="1">&amp;join;</ph> will add an extra backslash to the pathname before joining it to the filename.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517484</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="684" reformat="yes" translate="yes" xml:space="default">
        <source>I was overjoyed when I discovered this, since <bpt id="1">&lt;function&gt;</bpt>addSlashIfNecessary<ept id="1">&lt;/function&gt;</ept> is one of the stupid little functions I always need to write when building up my toolbox in a new language.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517485</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="685" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;emphasis&gt;</bpt>Do not<ept id="1">&lt;/emphasis&gt;</ept> write this stupid little function in <ph id="2">&amp;python;</ph>; smart people have already taken care of it for you.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517486</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="686" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;function&gt;</bpt>expanduser<ept id="1">&lt;/function&gt;</ept> will expand a pathname that uses <bpt id="2">&lt;literal&gt;</bpt>~<ept id="2">&lt;/literal&gt;</ept> to represent the current user's home directory.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517487</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="687" reformat="yes" translate="yes" xml:space="default">
        <source>This works on any platform where users have a home directory, like <ph id="1">&amp;windows;</ph>, <ph id="2">&amp;unix;</ph>, and <ph id="3">&amp;macosx;</ph>; it has no effect on <ph id="4">&amp;macos;</ph>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517488</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="688" reformat="yes" translate="yes" xml:space="default">
        <source>Combining these techniques, you can easily construct pathnames for directories and files under the user's home directory.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517489</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="689" reformat="yes" translate="yes" xml:space="default">
        <source>Splitting Pathnames</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517490</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="690" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;split;</ph> function splits a full pathname and returns a tuple containing the path and filename.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517491</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="691" reformat="yes" translate="yes" xml:space="default">
        <source>Remember when I said you could use <bpt id="1">&lt;link linkend=&quot;odbchelper.multiassign&quot;&gt;</bpt>multi-variable assignment<ept id="1">&lt;/link&gt;</ept> to return multiple values from a function?</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517492</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="692" reformat="yes" translate="yes" xml:space="default">
        <source>Well, <ph id="1">&amp;split;</ph> is such a function.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517493</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="693" reformat="yes" translate="yes" xml:space="default">
        <source>You assign the return value of the <ph id="1">&amp;split;</ph> function into a tuple of two variables.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517494</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="694" reformat="yes" translate="yes" xml:space="default">
        <source>Each variable receives the value of the corresponding element of the returned tuple.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517495</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="695" reformat="yes" translate="yes" xml:space="default">
        <source>The first variable, <bpt id="1">&lt;varname&gt;</bpt>filepath<ept id="1">&lt;/varname&gt;</ept>, receives the value of the first element of the tuple returned from <ph id="2">&amp;split;</ph>, the file path.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517496</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="696" reformat="yes" translate="yes" xml:space="default">
        <source>The second variable, <bpt id="1">&lt;varname&gt;</bpt>filename<ept id="1">&lt;/varname&gt;</ept>, receives the value of the second element of the tuple returned from <ph id="2">&amp;split;</ph>, the filename.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517497</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="697" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;ospath;</ph> also contains a function <ph id="2">&amp;splitext;</ph>, which splits a filename and returns a tuple containing the filename and the file extension.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517498</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="698" reformat="yes" translate="yes" xml:space="default">
        <source>You use the same technique to assign each of them to separate variables.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517499</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="699" reformat="yes" translate="yes" xml:space="default">
        <source>Listing Directories</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517500</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="700" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;listdir;</ph> function takes a pathname and returns a list of the contents of the directory.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517501</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="701" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;listdir;</ph> returns both files and folders, with no indication of which is which.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517502</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="702" reformat="yes" translate="yes" xml:space="default">
        <source>You can use <bpt id="1">&lt;link linkend=&quot;apihelper.filter&quot;&gt;</bpt>list filtering<ept id="1">&lt;/link&gt;</ept> and the <bpt id="2">&lt;function&gt;</bpt>isfile<ept id="2">&lt;/function&gt;</ept> function of the <ph id="3">&amp;ospath;</ph> module to separate the files from the folders.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517503</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="703" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;isfile;</ph> takes a pathname and returns 1 if the path represents a file, and 0 otherwise.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517504</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="704" reformat="yes" translate="yes" xml:space="default">
        <source>Here you're using <bpt id="1">&lt;literal&gt;</bpt>
          <ph id="2">&amp;ospath;</ph>.<ph id="3">&amp;join;</ph>
          <ept id="1">&lt;/literal&gt;</ept> to ensure a full pathname, but <ph id="4">&amp;isfile;</ph> also works with a partial path, relative to the current working directory.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517505</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="705" reformat="yes" translate="yes" xml:space="default">
        <source>You can use <bpt id="1">&lt;literal&gt;</bpt>os.getcwd()<ept id="1">&lt;/literal&gt;</ept> to get the current working directory.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517506</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="706" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;ospath;</ph> also has a <bpt id="2">&lt;function&gt;</bpt>isdir<ept id="2">&lt;/function&gt;</ept> function which returns 1 if the path represents a directory, and 0 otherwise.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517507</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="707" reformat="yes" translate="yes" xml:space="default">
        <source>You can use this to get a list of the subdirectories within a directory.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517508</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="708" reformat="yes" translate="yes" xml:space="default">
        <source>Listing Directories in <ph id="1">&amp;fileinfo_filename;</ph>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517509</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="709" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;literal&gt;</bpt>os.listdir(directory)<ept id="1">&lt;/literal&gt;</ept> returns a list of all the files and folders in <bpt id="2">&lt;varname&gt;</bpt>directory<ept id="2">&lt;/varname&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517510</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="710" reformat="yes" translate="yes" xml:space="default">
        <source>Iterating through the list with <bpt id="1">&lt;varname&gt;</bpt>f<ept id="1">&lt;/varname&gt;</ept>, you use <bpt id="2">&lt;literal&gt;</bpt>os.path.normcase(f)<ept id="2">&lt;/literal&gt;</ept> to normalize the case according to operating system defaults.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517511</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="711" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;function&gt;</bpt>normcase<ept id="1">&lt;/function&gt;</ept> is a useful little function that compensates for case-insensitive operating systems that think that <bpt id="2">&lt;filename&gt;</bpt>mahadeva.mp3<ept id="2">&lt;/filename&gt;</ept> and <bpt id="3">&lt;filename&gt;</bpt>mahadeva.MP3<ept id="3">&lt;/filename&gt;</ept> are the same file.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517512</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="712" reformat="yes" translate="yes" xml:space="default">
        <source>For instance, on <ph id="1">&amp;windows;</ph> and <ph id="2">&amp;macos;</ph>, <bpt id="3">&lt;function&gt;</bpt>normcase<ept id="3">&lt;/function&gt;</ept> will convert the entire filename to lowercase; on <ph id="4">&amp;unix;</ph>-compatible systems, it will return the filename unchanged.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517515</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="713" reformat="yes" translate="yes" xml:space="default">
        <source>Iterating through the normalized list with <bpt id="1">&lt;varname&gt;</bpt>f<ept id="1">&lt;/varname&gt;</ept> again, you use <bpt id="2">&lt;literal&gt;</bpt>os.path.splitext(f)<ept id="2">&lt;/literal&gt;</ept> to split each filename into name and extension.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517516</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="714" reformat="yes" translate="yes" xml:space="default">
        <source>For each file, you see if the extension is in the list of file extensions you care about (<bpt id="1">&lt;varname&gt;</bpt>fileExtList<ept id="1">&lt;/varname&gt;</ept>, which was passed to the <bpt id="2">&lt;function&gt;</bpt>listDirectory<ept id="2">&lt;/function&gt;</ept> function).</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517517</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="715" reformat="yes" translate="yes" xml:space="default">
        <source>For each file you care about, you use <bpt id="1">&lt;literal&gt;</bpt>os.path.join(directory, f)<ept id="1">&lt;/literal&gt;</ept> to construct the full pathname of the file, and return a list of the full pathnames.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517518</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="716" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="open">&lt;note id=&quot;tip.os&quot;&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517519</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="717" reformat="yes" translate="yes" xml:space="default">
        <source>Whenever possible, you should use the functions in <ph id="1">&amp;os;</ph> and <ph id="2">&amp;ospath;</ph> for file, directory, and path manipulations.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517520</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="718" reformat="yes" translate="yes" xml:space="default">
        <source>These modules are wrappers for platform-specific modules, so functions like <bpt id="1">&lt;function&gt;</bpt>os.path.split<ept id="1">&lt;/function&gt;</ept> work on <ph id="2">&amp;unix;</ph>, <ph id="3">&amp;windows;</ph>, <ph id="4">&amp;macos;</ph>, and any other platform supported by <ph id="5">&amp;python;</ph>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517521</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="719" reformat="yes" translate="yes" xml:space="default">
        <source>
          <it id="1" pos="close">&lt;/note&gt;</it>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517522</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="720" reformat="yes" translate="yes" xml:space="default">
        <source>There is one other way to get the contents of a directory.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517523</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="721" reformat="yes" translate="yes" xml:space="default">
        <source>It's very powerful, and it uses the sort of wildcards that you may already be familiar with from working on the command line.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517524</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="722" reformat="yes" translate="yes" xml:space="default">
        <source>Listing Directories with <ph id="1">&amp;glob;</ph>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517525</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="723" reformat="yes" translate="yes" xml:space="default">
        <source>As you saw earlier, <bpt id="1">&lt;function&gt;</bpt>os.listdir<ept id="1">&lt;/function&gt;</ept> simply takes a directory path and lists all files and directories in that directory.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517526</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="724" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;glob;</ph> module, on the other hand, takes a wildcard and returns the full path of all files and directories matching the wildcard.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517527</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="725" reformat="yes" translate="yes" xml:space="default">
        <source>Here the wildcard is a directory path plus &quot;*.mp3&quot;, which will match all <bpt id="1">&lt;filename&gt;</bpt>.mp3<ept id="1">&lt;/filename&gt;</ept> files.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517528</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="726" reformat="yes" translate="yes" xml:space="default">
        <source>Note that each element of the returned list already includes the full path of the file.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517529</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="727" reformat="yes" translate="yes" xml:space="default">
        <source>If you want to find all the files in a specific directory that start with &quot;s&quot; and end with &quot;.mp3&quot;, you can do that too.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517530</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="728" reformat="yes" translate="yes" xml:space="default">
        <source>Now consider this scenario:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517531</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="729" reformat="yes" translate="yes" xml:space="default">
        <source>you have a <bpt id="1">&lt;filename&gt;</bpt>music<ept id="1">&lt;/filename&gt;</ept> directory, with several subdirectories within it, with <bpt id="2">&lt;filename&gt;</bpt>.mp3<ept id="2">&lt;/filename&gt;</ept> files within each subdirectory.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517532</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="730" reformat="yes" translate="yes" xml:space="default">
        <source>You can get a list of all of those with a single call to <ph id="1">&amp;glob;</ph>, by using two wildcards at once.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517533</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="731" reformat="yes" translate="yes" xml:space="default">
        <source>One wildcard is the <bpt id="1">&lt;literal&gt;</bpt>&quot;*.mp3&quot;<ept id="1">&lt;/literal&gt;</ept> (to match <bpt id="2">&lt;filename&gt;</bpt>.mp3<ept id="2">&lt;/filename&gt;</ept> files), and one wildcard is <bpt id="3">&lt;emphasis&gt;</bpt>within the directory path itself<ept id="3">&lt;/emphasis&gt;</ept>, to match any subdirectory within <bpt id="4">&lt;filename&gt;</bpt>c:\music<ept id="4">&lt;/filename&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517534</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="732" reformat="yes" translate="yes" xml:space="default">
        <source>That's a crazy amount of power packed into one deceptively simple-looking function!</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517535</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="733" reformat="yes" translate="yes" xml:space="default">
        <source>Further Reading on the <ph id="1">&amp;os;</ph> Module</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517536</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="734" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;pythonknowledgebase;</ph> answers <bpt id="2">&lt;ulink url=&quot;&amp;url_pythonknowledgebase;index.phtml/fid/240&quot;&gt;</bpt>questions about the <ph id="3">&amp;os;</ph> module<ept id="2">&lt;/ulink&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517537</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="735" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;pythonlibraryreference;</ph> documents the <bpt id="2">&lt;ulink url=&quot;&amp;url_pythonlibraryreference;module-os.html&quot;&gt;</bpt>
          <ph id="3">&amp;os;</ph>
          <ept id="2">&lt;/ulink&gt;</ept> module and the <bpt id="4">&lt;ulink url=&quot;&amp;url_pythonlibraryreference;module-os.path.html&quot;&gt;</bpt>
          <ph id="5">&amp;ospath;</ph>
          <ept id="4">&lt;/ulink&gt;</ept> module.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517538</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="736" reformat="yes" translate="yes" xml:space="default">
        <source>Putting It All Together</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517539</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="737" reformat="yes" translate="yes" xml:space="default">
        <source>Once again, all the dominoes are in place.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517540</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="738" reformat="yes" translate="yes" xml:space="default">
        <source>You've seen how each line of code works.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517541</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="739" reformat="yes" translate="yes" xml:space="default">
        <source>Now let's step back and see how it all fits together.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517542</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="740" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;listdirectory;</ph>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517543</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="741" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;listdirectory;</ph> is the main attraction of this entire module.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517544</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="742" reformat="yes" translate="yes" xml:space="default">
        <source>It takes a directory (like <bpt id="1">&lt;filename class=&quot;directory&quot;&gt;</bpt>c:\music\_singles\<ept id="1">&lt;/filename&gt;</ept> in my case) and a list of interesting file extensions (like <bpt id="2">&lt;literal&gt;</bpt>['.mp3']<ept id="2">&lt;/literal&gt;</ept>), and it returns a list of class instances that act like dictionaries that contain metadata about each interesting file in that directory.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517545</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="743" reformat="yes" translate="yes" xml:space="default">
        <source>And it does it in just a few straightforward lines of code.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517546</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="744" reformat="yes" translate="yes" xml:space="default">
        <source>As you saw in the <bpt id="1">&lt;link linkend=&quot;fileinfo.os&quot;&gt;</bpt>previous section<ept id="1">&lt;/link&gt;</ept>, this line of code gets a list of the full pathnames of all the files in <bpt id="2">&lt;varname&gt;</bpt>directory<ept id="2">&lt;/varname&gt;</ept> that have an interesting file extension (as specified by <bpt id="3">&lt;varname&gt;</bpt>fileExtList<ept id="3">&lt;/varname&gt;</ept>).</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517547</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="745" reformat="yes" translate="yes" xml:space="default">
        <source>Old-school <ph id="1">&amp;pascal;</ph> programmers may be familiar with them, but most people give me a blank stare when I tell them that <ph id="2">&amp;python;</ph> supports <bpt id="3">&lt;emphasis&gt;</bpt>nested functions<ept id="3">&lt;/emphasis&gt;</ept> -- literally, a function within a function.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517548</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="746" reformat="yes" translate="yes" xml:space="default">
        <source>The nested function <bpt id="1">&lt;function&gt;</bpt>getFileInfoClass<ept id="1">&lt;/function&gt;</ept> can be called only from the function in which it is defined, <ph id="2">&amp;listdirectory;</ph>. As with any other function, you don't need an interface declaration or anything fancy; just define the function and code it.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517549</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="747" reformat="yes" translate="yes" xml:space="default">
        <source>Now that you've seen the <bpt id="1">&lt;link linkend=&quot;fileinfo.os&quot;&gt;</bpt>
          <ph id="2">&amp;os;</ph>
          <ept id="1">&lt;/link&gt;</ept> module, this line should make more sense.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517550</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="748" reformat="yes" translate="yes" xml:space="default">
        <source>It gets the extension of the file (<bpt id="1">&lt;literal&gt;</bpt>os.path.splitext(filename)[1]<ept id="1">&lt;/literal&gt;</ept>), forces it to uppercase (<bpt id="2">&lt;literal&gt;</bpt>.upper()<ept id="2">&lt;/literal&gt;</ept>), slices off the dot (<bpt id="3">&lt;literal&gt;</bpt>[1:]<ept id="3">&lt;/literal&gt;</ept>), and constructs a class name out of it with string formatting.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517551</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="749" reformat="yes" translate="yes" xml:space="default">
        <source>So <bpt id="1">&lt;filename&gt;</bpt>c:\music\ap\mahadeva.mp3<ept id="1">&lt;/filename&gt;</ept> becomes <bpt id="2">&lt;literal&gt;</bpt>.mp3<ept id="2">&lt;/literal&gt;</ept> becomes <bpt id="3">&lt;literal&gt;</bpt>.MP3<ept id="3">&lt;/literal&gt;</ept> becomes <bpt id="4">&lt;literal&gt;</bpt>MP3<ept id="4">&lt;/literal&gt;</ept> becomes <bpt id="5">&lt;literal&gt;</bpt>MP3FileInfo<ept id="5">&lt;/literal&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517552</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="750" reformat="yes" translate="yes" xml:space="default">
        <source>Having constructed the name of the handler class that would handle this file, you check to see if that handler class actually exists in this module.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517553</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="751" reformat="yes" translate="yes" xml:space="default">
        <source>If it does, you return the class, otherwise you return the base class <ph id="1">&amp;fileinfo_classname;</ph>. This is a very important point:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517555</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="752" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;emphasis&gt;</bpt>this function returns a class<ept id="1">&lt;/emphasis&gt;</ept>.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517556</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="753" reformat="yes" translate="yes" xml:space="default">
        <source>Not an instance of a class, but the class itself.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517557</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="754" reformat="yes" translate="yes" xml:space="default">
        <source>For each file in the <bpt id="1">&lt;quote&gt;</bpt>interesting files<ept id="1">&lt;/quote&gt;</ept> list (<bpt id="2">&lt;varname&gt;</bpt>fileList<ept id="2">&lt;/varname&gt;</ept>), you call <bpt id="3">&lt;function&gt;</bpt>getFileInfoClass<ept id="3">&lt;/function&gt;</ept> with the filename (<bpt id="4">&lt;varname&gt;</bpt>f<ept id="4">&lt;/varname&gt;</ept>).</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517558</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="755" reformat="yes" translate="yes" xml:space="default">
        <source>Calling <bpt id="1">&lt;literal&gt;</bpt>getFileInfoClass(f)<ept id="1">&lt;/literal&gt;</ept> returns a class; you don't know exactly which class, but you don't care.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517559</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="756" reformat="yes" translate="yes" xml:space="default">
        <source>You then create an instance of this class (whatever it is) and pass the filename (<bpt id="1">&lt;varname&gt;</bpt>f<ept id="1">&lt;/varname&gt;</ept> again), to the <ph id="2">&amp;init;</ph> method.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517560</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="757" reformat="yes" translate="yes" xml:space="default">
        <source>As you saw <bpt id="1">&lt;link linkend=&quot;fileinfo.specialmethods.setname&quot;&gt;</bpt>earlier in this chapter<ept id="1">&lt;/link&gt;</ept>, the <ph id="2">&amp;init;</ph> method of <ph id="3">&amp;fileinfo_classname;</ph> sets <bpt id="4">&lt;literal&gt;</bpt>self[&quot;name&quot;]<ept id="4">&lt;/literal&gt;</ept>, which triggers <ph id="5">&amp;setitem;</ph>, which is overridden in the descendant (<ph id="6">&amp;mp3fileinfo_classname;</ph>) to parse the file appropriately to pull out the file's metadata.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517561</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="758" reformat="yes" translate="yes" xml:space="default">
        <source>You do all that for each interesting file and return a list of the resulting instances.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517562</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="759" reformat="yes" translate="yes" xml:space="default">
        <source>Note that <ph id="1">&amp;listdirectory;</ph> is completely generic.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517563</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="760" reformat="yes" translate="yes" xml:space="default">
        <source>It doesn't know ahead of time which types of files it will be getting, or which classes are defined that could potentially handle those files.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517564</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="761" reformat="yes" translate="yes" xml:space="default">
        <source>It inspects the directory for the files to process, and then introspects its own module to see what special handler classes (like <ph id="1">&amp;mp3fileinfo_classname;</ph>) are defined.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517565</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="762" reformat="yes" translate="yes" xml:space="default">
        <source>You can extend this program to handle other types of files simply by defining an appropriately-named class:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517566</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="763" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;classname&gt;</bpt>HTMLFileInfo<ept id="1">&lt;/classname&gt;</ept> for <bpt id="2">&lt;acronym&gt;</bpt>HTML<ept id="2">&lt;/acronym&gt;</ept> files, <bpt id="3">&lt;classname&gt;</bpt>DOCFileInfo<ept id="3">&lt;/classname&gt;</ept> for <bpt id="4">&lt;application&gt;</bpt>Word<ept id="4">&lt;/application&gt;</ept>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517567</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="764" reformat="yes" translate="yes" xml:space="default">
        <source>
          <bpt id="1">&lt;literal&gt;</bpt>.doc<ept id="1">&lt;/literal&gt;</ept> files, and so forth.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517568</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="765" reformat="yes" translate="yes" xml:space="default">
        <source>
          <ph id="1">&amp;listdirectory;</ph> will handle them all, without modification, by handing off the real work to the appropriate classes and collating the results.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517569</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="766" reformat="yes" translate="yes" xml:space="default">
        <source>Summary</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517570</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="767" reformat="yes" translate="yes" xml:space="default">
        <source>The <ph id="1">&amp;fileinfo_filename;</ph> program introduced in <ph id="2">&lt;xref linkend=&quot;fileinfo&quot; endterm=&quot;fileinfo.numberonly&quot;/&gt;</ph> should now make perfect sense.</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517571</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="768" reformat="yes" translate="yes" xml:space="default">
        <source>Before diving into the next chapter, make sure you're comfortable doing the following things:</source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517572</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="769" reformat="yes" translate="yes" xml:space="default">
        <source>Catching exceptions with <bpt id="1">&lt;link linkend=&quot;fileinfo.exception&quot;&gt;</bpt>
          <ph id="2">&amp;tryexcept;</ph>
          <ept id="1">&lt;/link&gt;</ept>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517573</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="770" reformat="yes" translate="yes" xml:space="default">
        <source>Protecting external resources with <bpt id="1">&lt;link linkend=&quot;fileinfo.files.incode&quot;&gt;</bpt>
          <ph id="2">&amp;tryfinally;</ph>
          <ept id="1">&lt;/link&gt;</ept>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517574</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="771" reformat="yes" translate="yes" xml:space="default">
        <source>Reading from <bpt id="1">&lt;link linkend=&quot;fileinfo.files&quot;&gt;</bpt>files<ept id="1">&lt;/link&gt;</ept>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517575</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="772" reformat="yes" translate="yes" xml:space="default">
        <source>Assigning multiple values at once in a <bpt id="1">&lt;link linkend=&quot;fileinfo.multiassign.for.example&quot;&gt;</bpt>
          <ph id="2">&amp;for;</ph> loop<ept id="1">&lt;/link&gt;</ept>
        </source>
        <target state="new" xml:lang="KM-KH"/>
        <prop-group>
          <prop prop-type="entryid">1150875517576</prop>
        </prop-group>
      </trans-unit>
      <trans-unit approved="no" id="773" reformat="yes" translate="yes" xml:space="default">
        <source>Using the <bpt id="1">&lt;link linkend=&quot;fileinfo.os&quot;&gt;</bpt>
          <ph id="2">&amp;os;</ph>
          <ept id="1">&lt;/link&gt;</ept> module for all your cross-platform file manipulation needs</source>
        <target>xzcvzxfasd</target>
        <prop-group>
          <prop prop-type="entryid">1150875517577</prop>
        </prop-group>
      <note>sdgfsadfstr</note></trans-unit>
      <trans-unit approved="no" id="774" reformat="yes" translate="yes" xml:space="default">
        <source>Dynamically <bpt id="1">&lt;link linkend=&quot;fileinfo.alltogether&quot;&gt;</bpt>instantiating classes of unknown type<ept id="1">&lt;/link&gt;</ept> by treating classes as objects and passing them around</source>
        <target>sdfasdf</target>
        <prop-group>
          <prop prop-type="entryid">1150875517578</prop>
        </prop-group>
      <note>sadfasdf</note></trans-unit>
    </body>
  </file>
</xliff>